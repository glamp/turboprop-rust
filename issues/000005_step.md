# Step 5: Vector Index Storage and Retrieval

## Objective
Implement efficient vector storage and indexing system for fast similarity search.

## Tasks
1. Create vector index data structure with HNSW-like performance
2. Implement serialization/deserialization for persistent storage
3. Add metadata storage alongside vectors (file paths, line numbers, etc.)
4. Create index management in `.turboprop/` directory
5. Implement incremental index updates
6. Add comprehensive tests with poker codebase

## Technical Approach
- Use simple flat vector storage initially (optimize later if needed)
- Store vectors with associated metadata in binary format
- Index directory: `.turboprop/index/`
- Separate files for vectors and metadata
- Support for atomic index updates to handle concurrent access

## Dependencies to Add
- `bincode` - Binary serialization
- `memmap2` - Memory-mapped file access for performance

## Acceptance Criteria
- Stores embedding vectors with associated metadata efficiently
- Persists index to `.turboprop/` directory
- Supports loading existing index from disk
- Handles incremental updates (add/remove/update files)
- Atomic operations to prevent index corruption
- Index can be shared between multiple processes safely
- Performance scales reasonably with number of files

## Index Structure
```
.turboprop/
├── index/
│   ├── vectors.bin       # Vector embeddings
│   ├── metadata.json     # File paths, chunks, line numbers
│   └── config.yaml       # Index configuration
└── models/              # Cached embedding models
```

## Files Created/Modified
- `src/index.rs` - Vector index management
- `src/storage.rs` - Persistent storage operations
- `src/types.rs` - Add index-related data structures
- `tests/index_tests.rs` - Index storage and retrieval tests

## Test Cases
- Test index creation and persistence
- Test index loading from disk
- Test incremental updates
- Test concurrent access safety
- Test index integrity after crashes

## Proposed Solution

Based on analysis of the existing codebase, I will implement vector index storage and retrieval with the following approach:

### Implementation Plan
1. **Add Dependencies** - Add `bincode` and `memmap2` to Cargo.toml for efficient serialization and memory-mapped file access
2. **Storage Module (`src/storage.rs`)** - Implement atomic file operations and binary serialization for vectors and metadata
3. **Index Management (`src/index.rs`)** - Create persistent version of existing ChunkIndex with load/save capabilities
4. **Type Extensions (`src/types.rs`)** - Add IndexConfig, IndexMetadata, and persistence-related data structures
5. **Comprehensive Tests** - Test creation, loading, incremental updates, and concurrent access

### Technical Approach
- **Extend existing ChunkIndex**: Add persistence methods to current in-memory implementation
- **Atomic operations**: Use temporary files with atomic moves to prevent corruption
- **Binary format**: Store vectors in efficient binary format with metadata in JSON for human readability
- **Memory mapping**: Use memmap2 for efficient loading of large vector files
- **Index versioning**: Track schema version for future compatibility

### File Structure
```
.turboprop/
├── index/
│   ├── vectors.bin       # Binary vector data (via bincode)
│   ├── metadata.json     # File paths, chunks, line numbers
│   ├── config.yaml       # Index configuration  
│   └── version.txt       # Schema version
└── models/              # Existing embedding models cache
```

### Key Features
- **Incremental updates**: Compare file timestamps to update only changed files
- **Concurrent safety**: File locking and atomic operations prevent corruption
- **Performance**: Memory-mapped access for large vector files
- **Compatibility**: Version tracking for future schema changes
- **Recovery**: Validate index integrity on load with automatic rebuilding if corrupted