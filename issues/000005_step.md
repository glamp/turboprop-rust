# Step 5: Vector Index Storage and Retrieval

## Objective
Implement efficient vector storage and indexing system for fast similarity search.

## Tasks
1. Create vector index data structure with HNSW-like performance
2. Implement serialization/deserialization for persistent storage
3. Add metadata storage alongside vectors (file paths, line numbers, etc.)
4. Create index management in `.turboprop/` directory
5. Implement incremental index updates
6. Add comprehensive tests with poker codebase

## Technical Approach
- Use simple flat vector storage initially (optimize later if needed)
- Store vectors with associated metadata in binary format
- Index directory: `.turboprop/index/`
- Separate files for vectors and metadata
- Support for atomic index updates to handle concurrent access

## Dependencies to Add
- `bincode` - Binary serialization
- `memmap2` - Memory-mapped file access for performance

## Acceptance Criteria
- Stores embedding vectors with associated metadata efficiently
- Persists index to `.turboprop/` directory
- Supports loading existing index from disk
- Handles incremental updates (add/remove/update files)
- Atomic operations to prevent index corruption
- Index can be shared between multiple processes safely
- Performance scales reasonably with number of files

## Index Structure
```
.turboprop/
├── index/
│   ├── vectors.bin       # Vector embeddings
│   ├── metadata.json     # File paths, chunks, line numbers
│   └── config.yaml       # Index configuration
└── models/              # Cached embedding models
```

## Files Created/Modified
- `src/index.rs` - Vector index management
- `src/storage.rs` - Persistent storage operations
- `src/types.rs` - Add index-related data structures
- `tests/index_tests.rs` - Index storage and retrieval tests

## Test Cases
- Test index creation and persistence
- Test index loading from disk
- Test incremental updates
- Test concurrent access safety
- Test index integrity after crashes