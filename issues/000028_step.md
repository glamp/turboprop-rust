# Step 28: STDIO Transport Implementation

## Objective
Implement the STDIO transport layer for MCP communication, enabling JSON-RPC message exchange over stdin/stdout as per the MCP specification.

## Background
MCP servers communicate via JSON-RPC 2.0 messages over stdin/stdout. Each message is a single line of JSON followed by a newline. The transport layer must handle message parsing, validation, and proper error handling while ensuring logs don't interfere with the MCP protocol communication.

## Tasks
1. Implement STDIO transport for JSON-RPC message handling
2. Create async message processing with proper error handling
3. Add message validation and protocol compliance
4. Ensure proper separation of logs (stderr) from protocol messages (stdout)

## Implementation Details

### 1. Create STDIO Transport

Create `src/mcp/transport.rs`:
```rust
//! STDIO transport for MCP communication
//!
//! Handles JSON-RPC messages over stdin/stdout as per MCP specification.
//! Messages are newline-delimited JSON objects.

use anyhow::{Context, Result};
use serde_json::{Deserializer, StreamDeserializer};
use std::io::{self, BufRead, BufReader, Write};
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader as TokioBufReader, stdin, stdout};
use tokio::sync::mpsc;
use tracing::{debug, error, warn};

use super::protocol::{JsonRpcRequest, JsonRpcResponse, JsonRpcError};

/// STDIO transport for MCP communication
pub struct StdioTransport {
    /// Channel for receiving requests from stdin
    request_receiver: mpsc::UnboundedReceiver<Result<JsonRpcRequest>>,
    /// Channel for sending responses to stdout  
    response_sender: mpsc::UnboundedSender<JsonRpcResponse>,
    /// Handle for managing the transport tasks
    _handle: StdioTransportHandle,
}

/// Handle for managing STDIO transport background tasks
pub struct StdioTransportHandle {
    /// Task for reading from stdin
    stdin_task: tokio::task::JoinHandle<()>,
    /// Task for writing to stdout
    stdout_task: tokio::task::JoinHandle<()>,
}

impl StdioTransport {
    /// Create a new STDIO transport
    pub fn new() -> (Self, mpsc::UnboundedReceiver<JsonRpcResponse>) {
        let (request_tx, request_rx) = mpsc::unbounded_channel();
        let (response_tx, response_rx) = mpsc::unbounded_channel();
        
        // Start background tasks for stdin/stdout handling
        let stdin_task = tokio::spawn(Self::stdin_reader_task(request_tx));
        let stdout_task = tokio::spawn(Self::stdout_writer_task(response_rx));
        
        let handle = StdioTransportHandle {
            stdin_task,
            stdout_task,
        };
        
        let transport = Self {
            request_receiver: request_rx,
            response_sender: response_tx,
            _handle: handle,
        };
        
        (transport, response_rx)
    }
    
    /// Background task for reading JSON-RPC requests from stdin
    async fn stdin_reader_task(sender: mpsc::UnboundedSender<Result<JsonRpcRequest>>) {
        let stdin = stdin();
        let mut reader = BufReader::new(stdin);
        let mut line = String::new();
        
        loop {
            line.clear();
            
            match reader.read_line(&mut line).await {
                Ok(0) => {
                    // EOF reached
                    debug!("STDIN closed, stopping reader task");
                    break;
                }
                Ok(_) => {
                    // Parse JSON-RPC message
                    let trimmed = line.trim();
                    if trimmed.is_empty() {
                        continue;
                    }
                    
                    debug!("Received message: {}", trimmed);
                    
                    let request_result = serde_json::from_str::<JsonRpcRequest>(trimmed)
                        .with_context(|| format!("Failed to parse JSON-RPC request: {}", trimmed));
                    
                    if sender.send(request_result).is_err() {
                        error!("Failed to send request to handler, receiver dropped");
                        break;
                    }
                }
                Err(e) => {
                    error!("Error reading from stdin: {}", e);
                    let error_result = Err(anyhow::anyhow!("STDIN read error: {}", e));
                    if sender.send(error_result).is_err() {
                        break;
                    }
                }
            }
        }
    }
    
    /// Background task for writing JSON-RPC responses to stdout
    async fn stdout_writer_task(mut receiver: mpsc::UnboundedReceiver<JsonRpcResponse>) {
        let mut stdout = stdout();
        
        while let Some(response) = receiver.recv().await {
            match serde_json::to_string(&response) {
                Ok(json) => {
                    let message = format!("{}\n", json);
                    debug!("Sending response: {}", json);
                    
                    if let Err(e) = stdout.write_all(message.as_bytes()).await {
                        error!("Failed to write to stdout: {}", e);
                        break;
                    }
                    
                    if let Err(e) = stdout.flush().await {
                        error!("Failed to flush stdout: {}", e);
                        break;
                    }
                }
                Err(e) => {
                    error!("Failed to serialize response: {}", e);
                    // Try to send an error response
                    let error_response = JsonRpcResponse::error(
                        response.id,
                        JsonRpcError::internal_error(format!("Serialization error: {}", e))
                    );
                    
                    if let Ok(json) = serde_json::to_string(&error_response) {
                        let message = format!("{}\n", json);
                        let _ = stdout.write_all(message.as_bytes()).await;
                        let _ = stdout.flush().await;
                    }
                }
            }
        }
        
        debug!("STDOUT writer task finished");
    }
    
    /// Receive the next request from stdin
    pub async fn receive_request(&mut self) -> Option<Result<JsonRpcRequest>> {
        self.request_receiver.recv().await
    }
    
    /// Send a response to stdout
    pub fn send_response(&self, response: JsonRpcResponse) -> Result<()> {
        self.response_sender
            .send(response)
            .map_err(|_| anyhow::anyhow!("Response receiver dropped"))
    }
    
    /// Create an error response for invalid requests
    pub fn create_error_response(
        request_id: Option<serde_json::Value>, 
        error: JsonRpcError
    ) -> JsonRpcResponse {
        let id = request_id.unwrap_or(serde_json::Value::Null);
        JsonRpcResponse::error(id, error)
    }
}

impl Drop for StdioTransportHandle {
    fn drop(&mut self) {
        // Abort background tasks when handle is dropped
        self.stdin_task.abort();
        self.stdout_task.abort();
    }
}

/// Helper for validating JSON-RPC requests
pub struct RequestValidator;

impl RequestValidator {
    /// Validate a JSON-RPC request according to MCP requirements
    pub fn validate(request: &JsonRpcRequest) -> Result<(), JsonRpcError> {
        // Check JSON-RPC version
        if request.jsonrpc != "2.0" {
            return Err(JsonRpcError::invalid_request(
                format!("Invalid jsonrpc version: {}, expected '2.0'", request.jsonrpc)
            ));
        }
        
        // Check that ID is present (required for MCP)
        if request.id.is_null() {
            return Err(JsonRpcError::invalid_request(
                "Request ID is required and cannot be null".to_string()
            ));
        }
        
        // Check method name
        if request.method.is_empty() {
            return Err(JsonRpcError::invalid_request(
                "Method name cannot be empty".to_string()
            ));
        }
        
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use tokio::time::{timeout, Duration};
    
    #[test]
    fn test_request_validator() {
        // Valid request
        let valid_request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(1),
            method: "test_method".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&valid_request).is_ok());
        
        // Invalid JSON-RPC version
        let invalid_version = JsonRpcRequest {
            jsonrpc: "1.0".to_string(),
            id: json!(1),
            method: "test_method".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&invalid_version).is_err());
        
        // Null ID (not allowed in MCP)
        let null_id = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(null),
            method: "test_method".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&null_id).is_err());
        
        // Empty method name
        let empty_method = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(1),
            method: "".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&empty_method).is_err());
    }
    
    #[tokio::test]
    async fn test_transport_creation() {
        let (transport, _response_rx) = StdioTransport::new();
        
        // Transport should be created successfully
        // Background tasks should be running
        // This is mainly a compilation and basic functionality test
        drop(transport);
    }
    
    #[test]
    fn test_error_response_creation() {
        let error = JsonRpcError::method_not_found("unknown".to_string());
        let response = StdioTransport::create_error_response(Some(json!(123)), error);
        
        assert_eq!(response.id, json!(123));
        assert!(response.error.is_some());
        assert!(response.result.is_none());
        assert_eq!(response.error.unwrap().code, -32601);
    }
}
```

### 2. Add Transport Integration Helper

Add helper functions to `src/mcp/protocol.rs`:
```rust
// Add to existing protocol.rs file

/// Helper functions for transport integration
impl JsonRpcRequest {
    /// Validate this request according to MCP requirements
    pub fn validate(&self) -> Result<(), JsonRpcError> {
        crate::mcp::transport::RequestValidator::validate(self)
    }
    
    /// Create an error response for this request
    pub fn create_error_response(&self, error: JsonRpcError) -> JsonRpcResponse {
        JsonRpcResponse::error(self.id.clone(), error)
    }
    
    /// Create a success response for this request
    pub fn create_success_response(&self, result: serde_json::Value) -> JsonRpcResponse {
        JsonRpcResponse::success(self.id.clone(), result)
    }
}
```

### 3. Update MCP Module

Update `src/mcp/mod.rs` to include transport:
```rust
//! Model Context Protocol (MCP) implementation for TurboProp
//! 
//! Provides JSON-RPC 2.0 server implementation for exposing semantic search
//! capabilities to coding agents via the MCP protocol.
//!
//! The MCP server follows the official specification and provides:
//! - Real-time semantic search via the 'search' tool
//! - Automatic repository indexing and file watching
//! - Integration with existing TurboProp infrastructure

pub mod protocol;
pub mod server;
pub mod transport;
pub mod tools;

pub use server::McpServer;
pub use transport::StdioTransport;
```

## Files to Create/Modify
- `src/mcp/transport.rs` - STDIO transport implementation
- `src/mcp/protocol.rs` - Add helper methods for transport integration
- `src/mcp/mod.rs` - Export transport module

## Acceptance Criteria
- [ ] STDIO transport correctly handles JSON-RPC message parsing
- [ ] Messages are properly validated according to MCP specification
- [ ] Async message processing works without blocking
- [ ] Error handling provides meaningful error responses
- [ ] Logs go to stderr and don't interfere with stdout protocol messages
- [ ] Background tasks are properly managed and cleaned up
- [ ] Unit tests cover message validation and error cases

## Success Validation
```bash
# Verify the transport compiles correctly
cargo check

# Run unit tests for transport functionality
cargo test mcp::transport

# Test message serialization/deserialization
cargo test mcp::protocol

# Verify error handling
cargo test test_request_validator
```

## Notes
This step implements the core transport layer for MCP communication by:
- Creating async STDIO handling with proper message framing
- Implementing JSON-RPC 2.0 message validation per MCP requirements
- Ensuring proper separation of protocol messages (stdout) from logs (stderr)
- Adding comprehensive error handling with meaningful error responses
- Using tokio for async I/O without blocking the main event loop

The transport layer provides a clean interface for the MCP server to receive requests and send responses while handling all the low-level details of the JSON-RPC protocol over STDIO. This foundation enables the next steps to focus on implementing the actual MCP server logic and tools.