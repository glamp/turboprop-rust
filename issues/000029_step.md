# Step 29: Search Tool Implementation

## Objective
Implement the MCP search tool that exposes TurboProp's semantic search capabilities to coding agents with support for all search parameters and result formatting.

## Background
The search tool is the core functionality exposed by the MCP server. It must provide access to TurboProp's existing search capabilities while conforming to the MCP tool specification. The tool should support natural language queries and all existing search filters (filetype, glob patterns, similarity thresholds, etc.).

## Tasks
1. Implement the MCP search tool definition and schema
2. Integrate with existing TurboProp search infrastructure
3. Add parameter validation and error handling
4. Format search results for MCP consumption
5. Ensure search operations don't block the MCP server

## Implementation Details

### 1. Create Search Tool Implementation

Create `src/mcp/tools.rs`:
```rust
//! MCP tools for semantic search
//!
//! Implements the search tool that exposes TurboProp's semantic search
//! capabilities via MCP protocol

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::path::Path;
use tracing::{debug, info, warn};

use crate::config::TurboPropConfig;
use crate::query::SearchQuery;
use crate::search::{search_index, SearchOptions, SearchResult};
use crate::storage::PersistentChunkIndex;
use crate::types::{FileSize, SimilarityScore};

/// MCP tool definition for semantic search
#[derive(Debug, Clone, Serialize)]
pub struct SearchTool {
    /// Tool name (must be "search")
    pub name: String,
    /// Tool description for agents
    pub description: String,
    /// JSON schema for tool parameters
    #[serde(rename = "inputSchema")]
    pub input_schema: Value,
}

/// Parameters for the search tool
#[derive(Debug, Clone, Deserialize)]
pub struct SearchToolParams {
    /// Natural language search query (required)
    pub query: String,
    /// Maximum number of results to return
    #[serde(default = "default_limit")]
    pub limit: usize,
    /// Minimum similarity threshold (0.0 to 1.0)
    #[serde(default)]
    pub threshold: Option<f32>,
    /// Filter by file extension (e.g., ".rs", ".js", ".py")
    #[serde(default)]
    pub filetype: Option<String>,
    /// Glob pattern filter (e.g., "*.rs", "src/**/*.js")
    #[serde(default)]
    pub filter: Option<String>,
    /// Include file content in results
    #[serde(default)]
    pub include_content: Option<bool>,
    /// Context lines around matches
    #[serde(default)]
    pub context_lines: Option<usize>,
}

/// Search result formatted for MCP
#[derive(Debug, Clone, Serialize)]
pub struct McpSearchResult {
    /// Relative file path
    pub file_path: String,
    /// Line number of the match
    pub line_number: usize,
    /// Similarity score (0.0 to 1.0)
    pub similarity_score: f32,
    /// Matched text content
    pub content: String,
    /// Context lines around the match (if requested)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub context: Option<Vec<String>>,
    /// File type/extension
    pub file_type: String,
    /// Start and end positions in the chunk
    pub start_line: usize,
    pub end_line: usize,
}

/// Search tool execution result
#[derive(Debug, Clone, Serialize)]
pub struct SearchToolResult {
    /// Search results
    pub results: Vec<McpSearchResult>,
    /// Total number of results found (before limit)
    pub total_results: usize,
    /// Query execution time in milliseconds
    pub execution_time_ms: u64,
    /// Search parameters used
    pub query_info: SearchQueryInfo,
}

/// Information about the executed search query
#[derive(Debug, Clone, Serialize)]
pub struct SearchQueryInfo {
    /// Original query string
    pub query: String,
    /// Applied filters
    pub filters: SearchFilters,
    /// Limit applied
    pub limit: usize,
    /// Threshold used
    pub threshold: f32,
}

/// Applied search filters
#[derive(Debug, Clone, Serialize)]
pub struct SearchFilters {
    /// File type filter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filetype: Option<String>,
    /// Glob pattern filter
    #[serde(skip_serializing_if = "Option::is_none")]
    pub glob_pattern: Option<String>,
}

impl SearchTool {
    /// Create a new search tool
    pub fn new() -> Self {
        Self {
            name: "search".to_string(),
            description: "Semantic search across the indexed codebase using natural language queries. Supports filtering by file type, glob patterns, and similarity thresholds.".to_string(),
            input_schema: Self::create_input_schema(),
        }
    }
    
    /// Create the JSON schema for search tool parameters
    fn create_input_schema() -> Value {
        json!({
            "type": "object",
            "properties": {
                "query": {
                    "type": "string",
                    "description": "Natural language search query (e.g., 'find functions that handle user authentication', 'error handling code', 'JWT token validation')"
                },
                "limit": {
                    "type": "integer",
                    "description": "Maximum number of results to return (default: 10, max: 100)",
                    "default": 10,
                    "minimum": 1,
                    "maximum": 100
                },
                "threshold": {
                    "type": "number",
                    "description": "Minimum similarity threshold (0.0 to 1.0, default: use config value)",
                    "minimum": 0.0,
                    "maximum": 1.0
                },
                "filetype": {
                    "type": "string",
                    "description": "Filter by file extension (e.g., '.rs', '.js', '.py', '.md')",
                    "pattern": "^\\.[a-zA-Z0-9]+$"
                },
                "filter": {
                    "type": "string", 
                    "description": "Glob pattern filter (e.g., '*.rs', 'src/**/*.js', 'tests/**')"
                },
                "include_content": {
                    "type": "boolean",
                    "description": "Include full chunk content in results (default: true)",
                    "default": true
                },
                "context_lines": {
                    "type": "integer",
                    "description": "Number of context lines around matches (default: 0, max: 10)",
                    "default": 0,
                    "minimum": 0,
                    "maximum": 10
                }
            },
            "required": ["query"],
            "additionalProperties": false
        })
    }
    
    /// Execute the search tool
    pub async fn execute(
        &self,
        params: Value,
        index: &PersistentChunkIndex,
        config: &TurboPropConfig,
        repo_path: &Path,
    ) -> Result<Value> {
        let start_time = std::time::Instant::now();
        
        // Parse and validate parameters
        let search_params: SearchToolParams = serde_json::from_value(params)
            .context("Invalid search tool parameters")?;
        
        // Validate parameters
        self.validate_params(&search_params)?;
        
        debug!(
            "Executing search: query='{}', limit={}, threshold={:?}",
            search_params.query, search_params.limit, search_params.threshold
        );
        
        // Create search query
        let query = SearchQuery::new(&search_params.query);
        
        // Build search options
        let mut search_options = SearchOptions {
            limit: search_params.limit,
            threshold: search_params.threshold
                .map(SimilarityScore::new)
                .unwrap_or(config.search.similarity_threshold),
            ..Default::default()
        };
        
        // Apply filters
        if let Some(filetype) = &search_params.filetype {
            search_options = search_options.with_file_type(filetype);
        }
        
        if let Some(filter) = &search_params.filter {
            search_options = search_options.with_glob_filter(filter);
        }
        
        // Execute search
        let search_results = search_index(index, &query, &search_options)
            .await
            .context("Search execution failed")?;
        
        let execution_time = start_time.elapsed();
        
        // Convert results to MCP format
        let mcp_results = self.convert_results(
            search_results.results,
            repo_path,
            search_params.include_content.unwrap_or(true),
            search_params.context_lines.unwrap_or(0),
        ).await?;
        
        let total_results = search_results.total_matches;
        
        // Create response
        let result = SearchToolResult {
            results: mcp_results,
            total_results,
            execution_time_ms: execution_time.as_millis() as u64,
            query_info: SearchQueryInfo {
                query: search_params.query.clone(),
                filters: SearchFilters {
                    filetype: search_params.filetype,
                    glob_pattern: search_params.filter,
                },
                limit: search_params.limit,
                threshold: search_options.threshold.value(),
            },
        };
        
        info!(
            "Search completed: query='{}', results={}/{}, time={}ms",
            search_params.query,
            result.results.len(),
            total_results,
            result.execution_time_ms
        );
        
        Ok(serde_json::to_value(result)?)
    }
    
    /// Validate search tool parameters
    fn validate_params(&self, params: &SearchToolParams) -> Result<()> {
        // Validate query
        if params.query.trim().is_empty() {
            anyhow::bail!("Query cannot be empty");
        }
        
        if params.query.len() > 1000 {
            anyhow::bail!("Query too long (max 1000 characters)");
        }
        
        // Validate limit
        if params.limit > 100 {
            anyhow::bail!("Limit too high (max 100)");
        }
        
        // Validate threshold
        if let Some(threshold) = params.threshold {
            if threshold < 0.0 || threshold > 1.0 {
                anyhow::bail!("Threshold must be between 0.0 and 1.0");
            }
        }
        
        // Validate filetype format
        if let Some(filetype) = &params.filetype {
            if !filetype.starts_with('.') || filetype.len() < 2 {
                anyhow::bail!("File type must start with '.' and have at least one character (e.g., '.rs', '.js')");
            }
        }
        
        // Validate context lines
        if let Some(context_lines) = params.context_lines {
            if context_lines > 10 {
                anyhow::bail!("Context lines too high (max 10)");
            }
        }
        
        Ok(())
    }
    
    /// Convert TurboProp search results to MCP format
    async fn convert_results(
        &self,
        results: Vec<SearchResult>,
        repo_path: &Path,
        include_content: bool,
        context_lines: usize,
    ) -> Result<Vec<McpSearchResult>> {
        let mut mcp_results = Vec::new();
        
        for result in results {
            // Get relative path
            let relative_path = result.chunk.file_path
                .strip_prefix(repo_path)
                .unwrap_or(&result.chunk.file_path)
                .to_string_lossy()
                .to_string();
            
            // Extract file extension
            let file_type = result.chunk.file_path
                .extension()
                .and_then(|ext| ext.to_str())
                .unwrap_or("unknown")
                .to_string();
            
            // Get content
            let content = if include_content {
                result.chunk.content.clone()
            } else {
                // Provide a preview of the content
                let preview_len = 200;
                if result.chunk.content.len() > preview_len {
                    format!("{}...", &result.chunk.content[..preview_len])
                } else {
                    result.chunk.content.clone()
                }
            };
            
            // Add context lines if requested
            let context = if context_lines > 0 {
                // For now, return None - context line extraction would require
                // reading the full file content, which we can implement in a future step
                None
            } else {
                None
            };
            
            let mcp_result = McpSearchResult {
                file_path: relative_path,
                line_number: result.chunk.start_line,
                similarity_score: result.similarity_score.value(),
                content,
                context,
                file_type,
                start_line: result.chunk.start_line,
                end_line: result.chunk.end_line,
            };
            
            mcp_results.push(mcp_result);
        }
        
        Ok(mcp_results)
    }
}

impl Default for SearchTool {
    fn default() -> Self {
        Self::new()
    }
}

/// Default limit for search results
fn default_limit() -> usize {
    10
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    
    #[test]
    fn test_search_tool_creation() {
        let tool = SearchTool::new();
        
        assert_eq!(tool.name, "search");
        assert!(!tool.description.is_empty());
        assert!(tool.input_schema.is_object());
    }
    
    #[test]  
    fn test_search_params_deserialization() {
        let params = json!({
            "query": "test function",
            "limit": 5,
            "threshold": 0.7,
            "filetype": ".rs"
        });
        
        let search_params: SearchToolParams = serde_json::from_value(params).unwrap();
        
        assert_eq!(search_params.query, "test function");
        assert_eq!(search_params.limit, 5);
        assert_eq!(search_params.threshold, Some(0.7));
        assert_eq!(search_params.filetype, Some(".rs".to_string()));
    }
    
    #[test]
    fn test_search_params_defaults() {
        let params = json!({
            "query": "test function"
        });
        
        let search_params: SearchToolParams = serde_json::from_value(params).unwrap();
        
        assert_eq!(search_params.query, "test function");
        assert_eq!(search_params.limit, 10); // default
        assert_eq!(search_params.threshold, None);
        assert_eq!(search_params.filetype, None);
    }
    
    #[test]
    fn test_parameter_validation() {
        let tool = SearchTool::new();
        
        // Valid parameters
        let valid_params = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: Some(0.5),
            filetype: Some(".rs".to_string()),
            filter: None,
            include_content: Some(true),
            context_lines: Some(2),
        };
        assert!(tool.validate_params(&valid_params).is_ok());
        
        // Empty query
        let empty_query = SearchToolParams {
            query: "".to_string(),
            limit: 10,
            threshold: None,
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&empty_query).is_err());
        
        // Invalid threshold
        let invalid_threshold = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: Some(1.5),
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&invalid_threshold).is_err());
        
        // Invalid filetype
        let invalid_filetype = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: None,
            filetype: Some("rs".to_string()), // missing dot
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&invalid_filetype).is_err());
    }
    
    #[test]
    fn test_input_schema_structure() {
        let tool = SearchTool::new();
        let schema = &tool.input_schema;
        
        // Check required properties
        assert!(schema["properties"]["query"].is_object());
        assert!(schema["required"].as_array().unwrap().contains(&json!("query")));
        
        // Check optional properties
        assert!(schema["properties"]["limit"].is_object());
        assert!(schema["properties"]["threshold"].is_object());
        assert!(schema["properties"]["filetype"].is_object());
        assert!(schema["properties"]["filter"].is_object());
    }
}
```

### 2. Add Error Handling for Tool Execution

Add tool-specific error handling to `src/mcp/protocol.rs`:
```rust
// Add to existing protocol.rs file

/// Tool execution error codes (following JSON-RPC conventions)
pub mod tool_errors {
    /// Tool not found
    pub const TOOL_NOT_FOUND: i32 = -32000;
    /// Invalid tool parameters  
    pub const INVALID_TOOL_PARAMS: i32 = -32001;
    /// Tool execution failed
    pub const TOOL_EXECUTION_ERROR: i32 = -32002;
    /// Index not ready
    pub const INDEX_NOT_READY: i32 = -32003;
}

impl JsonRpcError {
    /// Create a tool not found error
    pub fn tool_not_found(tool_name: &str) -> Self {
        Self::new(
            tool_errors::TOOL_NOT_FOUND,
            format!("Tool not found: {}", tool_name),
            None,
        )
    }
    
    /// Create an invalid tool parameters error
    pub fn invalid_tool_params(message: String) -> Self {
        Self::new(
            tool_errors::INVALID_TOOL_PARAMS,
            format!("Invalid tool parameters: {}", message),
            None,
        )
    }
    
    /// Create a tool execution error
    pub fn tool_execution_error(message: String) -> Self {
        Self::new(
            tool_errors::TOOL_EXECUTION_ERROR,
            format!("Tool execution failed: {}", message),
            None,
        )
    }
    
    /// Create an index not ready error
    pub fn index_not_ready() -> Self {
        Self::new(
            tool_errors::INDEX_NOT_READY,
            "Search index is not ready. Please wait for indexing to complete.".to_string(),
            None,
        )
    }
}
```

## Files to Create/Modify
- `src/mcp/tools.rs` - Search tool implementation
- `src/mcp/protocol.rs` - Add tool-specific error codes
- `src/mcp/mod.rs` - Export tools module

## Acceptance Criteria
- [ ] Search tool correctly integrates with existing TurboProp search functionality
- [ ] Tool parameters are validated according to the JSON schema
- [ ] Search results are properly formatted for MCP consumption
- [ ] Error handling provides meaningful error messages
- [ ] Tool execution is async and doesn't block the MCP server
- [ ] All search filters (filetype, glob, threshold) work correctly
- [ ] Results include proper metadata (similarity scores, file paths, line numbers)
- [ ] Unit tests cover parameter validation and result formatting

## Success Validation
```bash
# Verify the search tool compiles correctly
cargo check

# Run unit tests for search tool functionality
cargo test mcp::tools

# Test parameter validation
cargo test test_parameter_validation

# Test JSON schema structure
cargo test test_input_schema_structure
```

## Notes
This step implements the core search tool functionality by:
- Creating a comprehensive tool definition with proper JSON schema
- Integrating with existing TurboProp search infrastructure
- Adding robust parameter validation and error handling
- Formatting results appropriately for MCP consumption
- Ensuring async execution without blocking the server

The search tool exposes all of TurboProp's search capabilities while maintaining the simplicity requested in the specification. The implementation reuses existing search logic and adds the MCP-specific formatting and validation layer on top.