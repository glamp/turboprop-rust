# Step 30: Main MCP Server Implementation

## Objective
Implement the core MCP server that coordinates JSON-RPC message handling, tool execution, and integration with TurboProp's indexing infrastructure.

## Background
The MCP server is the central component that handles the MCP protocol lifecycle: initialization, tool listing, tool execution, and graceful shutdown. It must integrate with TurboProp's existing file watching and indexing systems while providing a clean MCP interface to coding agents.

## Tasks
1. Implement the main MCP server with protocol lifecycle management
2. Add MCP method handlers (initialize, tools/list, tools/call)
3. Integrate with existing TurboProp indexing infrastructure
4. Add proper error handling and graceful shutdown
5. Ensure thread-safe index access for concurrent operations

## Implementation Details

### 1. Create Main MCP Server

Create `src/mcp/server.rs`:
```rust
//! Main MCP server implementation
//!
//! Coordinates file watching, incremental indexing, and search tool handling

use anyhow::{Context, Result};
use serde_json::{json, Value};
use std::path::{Path, PathBuf};
use std::sync::Arc;
use tokio::select;
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};

use crate::config::TurboPropConfig;
use crate::storage::PersistentChunkIndex;

use super::protocol::{
    constants, InitializeParams, InitializeResult, JsonRpcError, JsonRpcRequest, JsonRpcResponse,  
    ServerCapabilities, ServerInfo, ToolsCapability
};
use super::tools::SearchTool;
use super::transport::StdioTransport;

/// Main MCP server
pub struct McpServer {
    /// Repository path being indexed
    repo_path: PathBuf,
    /// TurboProp configuration
    config: TurboPropConfig,
    /// Search tool instance
    search_tool: SearchTool,
    /// Persistent index (wrapped for thread safety)
    index: Arc<RwLock<Option<PersistentChunkIndex>>>,
    /// Server initialization state
    initialized: Arc<RwLock<bool>>,
}

/// MCP server execution context
struct ServerContext {
    /// Server instance
    server: Arc<McpServer>,
    /// STDIO transport
    transport: StdioTransport,
}

impl McpServer {
    /// Create a new MCP server
    pub async fn new(repo_path: &Path, config: &TurboPropConfig) -> Result<Self> {
        info!("Initializing MCP server for {}", repo_path.display());
        
        let server = Self {
            repo_path: repo_path.to_path_buf(),
            config: config.clone(),
            search_tool: SearchTool::new(),
            index: Arc::new(RwLock::new(None)),
            initialized: Arc::new(RwLock::new(false)),
        };
        
        Ok(server)
    }
    
    /// Run the MCP server
    pub async fn run(self) -> Result<()> {
        let server = Arc::new(self);
        
        // Initialize transport
        let (mut transport, _response_rx) = StdioTransport::new();
        
        info!("MCP server ready and listening on stdio...");
        
        // Main message processing loop
        loop {
            match transport.receive_request().await {
                Some(Ok(request)) => {
                    let response = server.handle_request(request).await;
                    if let Err(e) = transport.send_response(response) {
                        error!("Failed to send response: {}", e);
                        break;
                    }
                }
                Some(Err(e)) => {
                    error!("Error receiving request: {}", e);
                    // Send error response if possible
                    let error_response = StdioTransport::create_error_response(
                        None,
                        JsonRpcError::parse_error(e.to_string()),
                    );
                    let _ = transport.send_response(error_response);
                }
                None => {
                    // STDIN closed
                    info!("STDIN closed, shutting down MCP server");
                    break;
                }
            }
        }
        
        Ok(())
    }
    
    /// Handle an incoming JSON-RPC request
    async fn handle_request(&self, request: JsonRpcRequest) -> JsonRpcResponse {
        debug!("Handling request: method={}, id={:?}", request.method, request.id);
        
        // Validate request format
        if let Err(error) = request.validate() {
            return request.create_error_response(error);
        }
        
        // Dispatch to appropriate handler
        match request.method.as_str() {
            constants::methods::INITIALIZE => self.handle_initialize(request).await,
            constants::methods::TOOLS_LIST => self.handle_tools_list(request).await,
            constants::methods::TOOLS_CALL => self.handle_tools_call(request).await,
            _ => {
                let error = JsonRpcError::method_not_found(request.method.clone());
                request.create_error_response(error)
            }
        }
    }
    
    /// Handle MCP initialization
    async fn handle_initialize(&self, request: JsonRpcRequest) -> JsonRpcResponse {
        debug!("Handling initialize request");
        
        // Parse initialization parameters
        let params = match request.params {
            Some(params) => match serde_json::from_value::<InitializeParams>(params) {
                Ok(params) => params,
                Err(e) => {
                    let error = JsonRpcError::invalid_params(format!("Invalid initialize params: {}", e));
                    return request.create_error_response(error);
                }
            },
            None => {
                let error = JsonRpcError::invalid_params("Missing initialize parameters".to_string());
                return request.create_error_response(error);
            }
        };
        
        info!(
            "Initializing MCP server for client: {} v{}",
            params.client_info.name, params.client_info.version
        );
        
        // Validate protocol version
        if params.protocol_version != constants::PROTOCOL_VERSION {
            warn!(
                "Client protocol version {} differs from server version {}",
                params.protocol_version, constants::PROTOCOL_VERSION
            );
        }
        
        // Start index initialization in background
        let index_clone = Arc::clone(&self.index);
        let repo_path = self.repo_path.clone();
        let config = self.config.clone();
        let initialized_flag = Arc::clone(&self.initialized);
        
        tokio::spawn(async move {
            match Self::initialize_index(&repo_path, &config).await {
                Ok(index) => {
                    {
                        let mut index_guard = index_clone.write().await;
                        *index_guard = Some(index);
                    }
                    {
                        let mut initialized_guard = initialized_flag.write().await;
                        *initialized_guard = true;
                    }
                    info!("Index initialization completed");
                }
                Err(e) => {
                    error!("Failed to initialize index: {}", e);
                    // Note: Server continues to run but search will return errors
                }
            }
        });
        
        // Create initialization result
        let result = InitializeResult {
            protocol_version: constants::PROTOCOL_VERSION.to_string(),
            server_info: ServerInfo {
                name: constants::SERVER_NAME.to_string(),
                version: constants::SERVER_VERSION.to_string(),
            },
            capabilities: ServerCapabilities {
                tools: Some(ToolsCapability {
                    list_changed: false, // Static tool list
                }),
                experimental: std::collections::HashMap::new(),
            },
        };
        
        match serde_json::to_value(result) {
            Ok(result_value) => {
                info!("MCP server initialized successfully");
                request.create_success_response(result_value)
            }
            Err(e) => {
                let error = JsonRpcError::internal_error(format!("Failed to serialize result: {}", e));
                request.create_error_response(error)
            }
        }
    }
    
    /// Handle tools/list request
    async fn handle_tools_list(&self, request: JsonRpcRequest) -> JsonRpcResponse {
        debug!("Handling tools/list request");
        
        let tools = vec![self.search_tool.clone()];
        
        let result = json!({
            "tools": tools
        });
        
        request.create_success_response(result)
    }
    
    /// Handle tools/call request
    async fn handle_tools_call(&self, request: JsonRpcRequest) -> JsonRpcResponse {
        debug!("Handling tools/call request");
        
        // Check if server is initialized
        let initialized = {
            let initialized_guard = self.initialized.read().await;
            *initialized_guard
        };
        
        if !initialized {
            let error = JsonRpcError::index_not_ready();
            return request.create_error_response(error);
        }
        
        // Parse tool call parameters
        let params = match request.params {
            Some(params) => params,
            None => {
                let error = JsonRpcError::invalid_params("Missing tool call parameters".to_string());
                return request.create_error_response(error);
            }
        };
        
        // Extract tool name and arguments
        let tool_name = match params.get("name").and_then(|v| v.as_str()) {
            Some(name) => name,
            None => {
                let error = JsonRpcError::invalid_params("Missing tool name".to_string());
                return request.create_error_response(error);
            }
        };
        
        let arguments = params.get("arguments").cloned().unwrap_or(json!({}));
        
        // Execute tool
        match tool_name {
            "search" => {
                // Get index
                let index_guard = self.index.read().await;
                let index = match index_guard.as_ref() {
                    Some(index) => index,
                    None => {
                        let error = JsonRpcError::index_not_ready();
                        return request.create_error_response(error);
                    }
                };
                
                // Execute search tool
                match self.search_tool.execute(arguments, index, &self.config, &self.repo_path).await {
                    Ok(result) => {
                        debug!("Search tool executed successfully");
                        request.create_success_response(result)
                    }
                    Err(e) => {
                        error!("Search tool execution failed: {}", e);
                        let error = JsonRpcError::tool_execution_error(e.to_string());
                        request.create_error_response(error)
                    }
                }
            }
            _ => {
                let error = JsonRpcError::tool_not_found(tool_name);
                request.create_error_response(error)
            }
        }
    }
    
    /// Initialize the search index
    async fn initialize_index(repo_path: &Path, config: &TurboPropConfig) -> Result<PersistentChunkIndex> {
        info!("Initializing search index for {}", repo_path.display());
        
        // Check if index already exists
        let index_path = config.get_index_path(repo_path);
        
        let index = if index_path.exists() {
            info!("Loading existing index from {}", index_path.display());
            PersistentChunkIndex::load_from_path(&index_path)
                .await
                .context("Failed to load existing index")?
        } else {
            info!("Creating new index");
            
            // Use existing TurboProp indexing logic
            let index = crate::commands::index::build_index(repo_path, config)
                .await
                .context("Failed to build initial index")?;
            
            info!("Index created successfully with {} chunks", index.chunk_count());
            index
        };
        
        Ok(index)
    }
}

/// MCP server builder for configuration
pub struct McpServerBuilder {
    repo_path: Option<PathBuf>,
    config: Option<TurboPropConfig>,
}

impl McpServerBuilder {
    /// Create a new server builder
    pub fn new() -> Self {
        Self {
            repo_path: None,
            config: None,
        }
    }
    
    /// Set the repository path
    pub fn repo_path<P: AsRef<Path>>(mut self, path: P) -> Self {
        self.repo_path = Some(path.as_ref().to_path_buf());
        self
    }
    
    /// Set the configuration
    pub fn config(mut self, config: TurboPropConfig) -> Self {
        self.config = Some(config);
        self
    }
    
    /// Build the MCP server
    pub async fn build(self) -> Result<McpServer> {
        let repo_path = self.repo_path
            .ok_or_else(|| anyhow::anyhow!("Repository path is required"))?;
        let config = self.config
            .ok_or_else(|| anyhow::anyhow!("Configuration is required"))?;
        
        McpServer::new(&repo_path, &config).await
    }
}

impl Default for McpServerBuilder {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;
    use tempfile::TempDir;
    
    #[tokio::test]
    async fn test_mcp_server_creation() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let server = McpServer::new(temp_dir.path(), &config).await;
        assert!(server.is_ok());
    }
    
    #[tokio::test]
    async fn test_initialize_request() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(1),
            constants::methods::INITIALIZE.to_string(),
            Some(json!({
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {
                    "name": "test-client",
                    "version": "1.0.0"
                },
                "capabilities": {}
            }))
        );
        
        let response = server.handle_initialize(request).await;
        
        assert!(response.error.is_none());
        assert!(response.result.is_some());
        
        let result = response.result.unwrap();
        assert_eq!(result["protocolVersion"], constants::PROTOCOL_VERSION);
        assert_eq!(result["serverInfo"]["name"], constants::SERVER_NAME);
    }
    
    #[tokio::test]
    async fn test_tools_list_request() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(1),
            constants::methods::TOOLS_LIST.to_string(),
            None
        );
        
        let response = server.handle_tools_list(request).await;
        
        assert!(response.error.is_none());
        assert!(response.result.is_some());
        
        let result = response.result.unwrap();
        let tools = result["tools"].as_array().unwrap();
        assert_eq!(tools.len(), 1);
        assert_eq!(tools[0]["name"], "search");
    }
    
    #[test]
    fn test_server_builder() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let builder = McpServerBuilder::new()
            .repo_path(temp_dir.path())
            .config(config);
        
        // Builder should be created successfully
        // Actual build() test would require async context
        drop(builder);
    }
    
    #[tokio::test]
    async fn test_invalid_method_request() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(1),
            "invalid_method".to_string(),
            None
        );
        
        let response = server.handle_request(request).await;
        
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        assert_eq!(response.error.unwrap().code, -32601); // Method not found
    }
    
    #[tokio::test]
    async fn test_tools_call_before_initialization() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(1),
            constants::methods::TOOLS_CALL.to_string(),
            Some(json!({
                "name": "search",
                "arguments": {
                    "query": "test"
                }
            }))
        );
        
        let response = server.handle_tools_call(request).await;
        
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        // Should return index not ready error
    }
}
```

### 2. Add Index Building Integration

Update `src/commands/index.rs` to expose the index building functionality:
```rust
// Add to existing index.rs file

/// Build an index for MCP server use
pub async fn build_index(
    repo_path: &Path,
    config: &TurboPropConfig,
) -> Result<PersistentChunkIndex> {
    // Use existing index building logic
    execute_index_command(
        repo_path,
        config,
        false, // force_rebuild
        false, // verbose
    ).await
}
```

### 3. Update MCP Module

Update `src/mcp/mod.rs` to export the server:
```rust
//! Model Context Protocol (MCP) implementation for TurboProp
//! 
//! Provides JSON-RPC 2.0 server implementation for exposing semantic search
//! capabilities to coding agents via the MCP protocol.
//!
//! The MCP server follows the official specification and provides:
//! - Real-time semantic search via the 'search' tool
//! - Automatic repository indexing and file watching
//! - Integration with existing TurboProp infrastructure

pub mod protocol;
pub mod server;
pub mod transport;
pub mod tools;

pub use server::{McpServer, McpServerBuilder};
pub use transport::StdioTransport;
```

## Files to Create/Modify
- `src/mcp/server.rs` - Main MCP server implementation
- `src/commands/index.rs` - Export index building function
- `src/mcp/mod.rs` - Export server types

## Acceptance Criteria
- [ ] MCP server correctly handles all required protocol methods
- [ ] Initialization process works properly with background index building
- [ ] Tool execution is properly coordinated with index availability
- [ ] Error handling provides meaningful responses for all error conditions
- [ ] Server can handle concurrent requests safely
- [ ] Graceful shutdown works when STDIN is closed
- [ ] Unit tests cover all major server functionality

## Success Validation
```bash
# Verify the server compiles correctly
cargo check

# Run unit tests for server functionality
cargo test mcp::server

# Test initialization and tool handling
cargo test test_initialize_request
cargo test test_tools_list_request

# Test error conditions
cargo test test_invalid_method_request
cargo test test_tools_call_before_initialization
```

## Notes
This step implements the core MCP server functionality by:
- Creating a complete MCP protocol implementation with proper lifecycle management
- Integrating with existing TurboProp indexing infrastructure
- Adding thread-safe index access for concurrent search operations
- Implementing proper error handling for all protocol violations and runtime errors
- Supporting background index initialization without blocking the server startup

The server provides a clean, robust foundation for the MCP protocol while leveraging all of TurboProp's existing capabilities. The implementation follows async/await patterns throughout and ensures proper resource management.

## Proposed Solution

The main MCP server implementation has been completed with the following key components:

### 1. Core MCP Server (`src/mcp/server.rs`)
- **Complete protocol lifecycle management** - The server handles all required MCP methods: initialize, tools/list, and tools/call
- **Background index initialization** - The server starts immediately and builds the index in the background, allowing for responsive startup
- **Thread-safe index access** - Uses `Arc<RwLock<>>` for safe concurrent access to the persistent index
- **Proper error handling** - All error conditions return meaningful MCP-compliant JSON-RPC error responses
- **Graceful shutdown** - Server properly handles STDIN closure and shuts down cleanly

### 2. Enhanced Search Integration
- **Added SearchEngine constructor** - Created `SearchEngine::from_existing_index()` method that accepts an already-loaded `PersistentChunkIndex`
- **Optimized search tool execution** - The MCP search tool now uses the server's persistent index directly instead of loading from disk each time
- **Added Clone support** - Added `Clone` derives to `PersistentChunkIndex`, `ChunkIndex`, and `IndexStorage` to support efficient index sharing

### 3. Index Building Integration (`src/commands/index.rs`)
- **Exposed build_index function** - The MCP server can now leverage existing TurboProp indexing logic
- **Seamless integration** - The server uses the same index building process as the CLI commands

### 4. Module Organization (`src/mcp/mod.rs`)
- **Proper exports** - All server types (`McpServer`, `McpServerBuilder`) are properly exported
- **Clean API surface** - The module provides a clean interface for external usage

### 5. Key Architectural Decisions
- **Reuse existing infrastructure** - The implementation leverages all existing TurboProp components (indexing, search, configuration)
- **Thread-safe design** - All shared state uses appropriate synchronization primitives
- **Async throughout** - The entire implementation is async/await compatible
- **Error resilience** - The server continues running even if index initialization fails, providing graceful degradation

### 6. Performance Optimizations
- **Index reuse** - The persistent index is loaded once and reused for all search operations
- **Background initialization** - Index building doesn't block server startup
- **Efficient search** - Direct use of loaded index eliminates repeated disk access

All acceptance criteria have been met:
- ✅ MCP server correctly handles all required protocol methods
- ✅ Initialization process works properly with background index building  
- ✅ Tool execution is properly coordinated with index availability
- ✅ Error handling provides meaningful responses for all error conditions
- ✅ Server can handle concurrent requests safely
- ✅ Graceful shutdown works when STDIN is closed
- ✅ Unit tests cover all major server functionality