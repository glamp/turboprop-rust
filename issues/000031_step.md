# Step 31: CLI Command Implementation

## Objective
Add the `tp mcp` command to TurboProp's CLI interface, enabling users to start the MCP server with proper configuration and argument handling.

## Background
The MCP server needs to be accessible via a simple CLI command that integrates with TurboProp's existing CLI structure. The command should support all relevant configuration options and provide a clean user experience for starting the server.

## Tasks
1. Add MCP command to the CLI structure
2. Implement the MCP command handler
3. Integrate with existing configuration loading
4. Add proper argument validation and help text
5. Update the main binary to handle the MCP command

## Implementation Details

### 1. Update CLI Structure

Update `src/cli.rs` to add the MCP command:
```rust
// Add to existing cli.rs file

use clap::{Args, Parser, Subcommand};
use std::path::PathBuf;

// ... existing imports and structures ...

#[derive(Debug, Subcommand)]
pub enum Commands {
    // ... existing commands ...
    
    /// Start MCP server for real-time semantic search
    /// 
    /// The MCP (Model Context Protocol) server enables integration with coding
    /// agents like Claude Code, GitHub Copilot, Cursor, and Windsurf. It provides
    /// real-time semantic search capabilities over your codebase.
    Mcp(McpArgs),
}

/// Arguments for the MCP server command
#[derive(Debug, Args)]
pub struct McpArgs {
    /// Repository path to index and watch
    /// 
    /// The MCP server will index all files in this repository and watch for
    /// changes to keep the index up-to-date.
    #[arg(long, default_value = ".", value_name = "PATH")]
    pub repo: PathBuf,
    
    /// Embedding model to use for semantic search
    /// 
    /// Overrides the model specified in the configuration file. Use 'tp model list'
    /// to see available models.
    #[arg(long, value_name = "MODEL")]
    pub model: Option<String>,
    
    /// Maximum file size to index
    /// 
    /// Files larger than this size will be skipped during indexing.
    /// Examples: "1mb", "2.5MB", "500kb"
    #[arg(long, value_name = "SIZE")]
    pub max_filesize: Option<String>,
    
    /// Only index files matching this glob pattern
    /// 
    /// Examples: "*.rs", "src/**/*.js", "**/*.py"
    #[arg(long, value_name = "PATTERN")]
    pub filter: Option<String>,
    
    /// Only index files of this type
    /// 
    /// Examples: "rust", "javascript", "python"
    #[arg(long, value_name = "TYPE")]  
    pub filetype: Option<String>,
    
    /// Force rebuild of the index even if it exists
    /// 
    /// Useful when changing models or after major configuration changes.
    #[arg(long)]
    pub force_rebuild: bool,
    
    /// Enable verbose logging
    /// 
    /// Logs are written to stderr to avoid interfering with MCP protocol
    /// messages on stdout.
    #[arg(short, long)]
    pub verbose: bool,
    
    /// Show additional debug information
    /// 
    /// Enables debug-level logging for troubleshooting MCP server issues.
    #[arg(long)]
    pub debug: bool,
}

impl McpArgs {
    /// Validate MCP command arguments
    pub fn validate(&self) -> Result<(), String> {
        // Validate repository path
        if !self.repo.exists() {
            return Err(format!("Repository path does not exist: {}", self.repo.display()));
        }
        
        if !self.repo.is_dir() {
            return Err(format!("Repository path is not a directory: {}", self.repo.display()));
        }
        
        // Validate file size format if provided
        if let Some(max_filesize) = &self.max_filesize {
            if let Err(e) = crate::types::files::FileSize::parse(max_filesize) {
                return Err(format!("Invalid file size format '{}': {}", max_filesize, e));
            }
        }
        
        // Validate glob pattern if provided
        if let Some(filter) = &self.filter {
            if let Err(e) = glob::Pattern::new(filter) {
                return Err(format!("Invalid glob pattern '{}': {}", filter, e));
            }
        }
        
        Ok(())
    }
}
```

### 2. Create MCP Command Handler

Create `src/commands/mcp.rs`:
```rust
//! MCP server command implementation
//!
//! Provides the `tp mcp` command that starts an MCP server for real-time
//! semantic search integration with coding agents.

use anyhow::{Context, Result};
use std::path::Path;
use tracing::{info, warn, debug, Level};
use tracing_subscriber::{EnvFilter, fmt::format::FmtSpan};

use crate::cli::McpArgs;
use crate::config::{TurboPropConfig, load_config_from_path};
use crate::mcp::McpServer;
use crate::types::files::FileSize;

/// Execute the MCP server command
pub async fn execute_mcp_command(args: McpArgs) -> Result<()> {
    // Set up logging (to stderr to avoid interfering with MCP protocol)
    setup_logging(args.verbose, args.debug)?;
    
    info!("Starting TurboProp MCP server");
    debug!("MCP arguments: {:?}", args);
    
    // Validate arguments
    args.validate()
        .map_err(|e| anyhow::anyhow!("Invalid arguments: {}", e))?;
    
    // Load configuration
    let mut config = load_config_from_path(&args.repo)
        .with_context(|| format!("Failed to load configuration for {}", args.repo.display()))?;
    
    // Apply CLI overrides
    apply_config_overrides(&mut config, &args)?;
    
    // Log configuration summary
    log_config_summary(&config, &args);
    
    // Create and run MCP server
    let server = McpServer::new(&args.repo, &config)
        .await
        .context("Failed to create MCP server")?;
    
    info!(
        "MCP server starting for repository: {}",
        args.repo.display()
    );
    info!("Ready to accept connections from coding agents");
    info!("Use Ctrl+C or close stdin to shutdown");
    
    // Run the server (this blocks until shutdown)
    server.run()
        .await
        .context("MCP server execution failed")?;
    
    info!("MCP server shutdown complete");
    Ok(())
}

/// Apply CLI argument overrides to configuration
fn apply_config_overrides(config: &mut TurboPropConfig, args: &McpArgs) -> Result<()> {
    // Override model if specified
    if let Some(model) = &args.model {
        config.embedding.model = model.clone();
    }
    
    // Override max file size if specified
    if let Some(max_filesize_str) = &args.max_filesize {
        let max_filesize = FileSize::parse(max_filesize_str)
            .with_context(|| format!("Invalid file size: {}", max_filesize_str))?;
        config.file_discovery.max_filesize = max_filesize;
    }
    
    // Override filters if specified
    if let Some(filter) = &args.filter {
        config.file_discovery.include_patterns = vec![filter.clone()];
    }
    
    if let Some(filetype) = &args.filetype {
        config.file_discovery.file_types = Some(vec![filetype.clone()]);
    }
    
    // Set force rebuild flag
    if args.force_rebuild {
        config.indexing.force_rebuild = true;
    }
    
    Ok(())
}

/// Set up logging for the MCP server
fn setup_logging(verbose: bool, debug: bool) -> Result<()> {
    let log_level = if debug {
        Level::DEBUG
    } else if verbose {
        Level::INFO
    } else {
        Level::WARN
    };
    
    // Create filter that respects RUST_LOG environment variable
    let filter = EnvFilter::builder()
        .with_default_directive(log_level.into())
        .from_env()
        .context("Failed to create log filter")?;
    
    // Configure subscriber to write to stderr (not stdout which is used for MCP)
    tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_writer(std::io::stderr)
        .with_span_events(FmtSpan::CLOSE)
        .with_target(false)
        .with_thread_ids(false)
        .with_file(false)
        .with_line_number(false)
        .init();
    
    debug!("Logging initialized");
    Ok(())
}

/// Log configuration summary for debugging
fn log_config_summary(config: &TurboPropConfig, args: &McpArgs) {
    info!("Configuration summary:");
    info!("  Repository: {}", args.repo.display());
    info!("  Model: {}", config.embedding.model);
    info!("  Max file size: {}", config.file_discovery.max_filesize);
    info!("  Batch size: {}", config.embedding.batch_size);
    
    if let Some(filter) = &args.filter {
        info!("  Filter pattern: {}", filter);
    }
    
    if let Some(filetype) = &args.filetype {
        info!("  File type: {}", filetype);
    }
    
    if args.force_rebuild {
        info!("  Force rebuild: enabled");
    }
    
    debug!("Full configuration: {:#?}", config);
}

/// Display helpful information for setting up MCP with coding agents
pub fn print_setup_info(repo_path: &Path) {
    eprintln!();
    eprintln!("ðŸš€ TurboProp MCP Server Started");
    eprintln!("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    eprintln!("Repository: {}", repo_path.display());
    eprintln!();
    eprintln!("To integrate with coding agents, add this to your MCP configuration:");
    eprintln!();
    eprintln!("Claude Code (.mcp.json):");
    eprintln!(r#"{{
  "mcpServers": {{
    "turboprop": {{
      "command": "tp",
      "args": ["mcp", "--repo", "{}"]
    }}
  }}
}}"#, repo_path.display());
    eprintln!();
    eprintln!("Cursor (.cursor/mcp.json):");
    eprintln!(r#"{{
  "mcpServers": {{
    "turboprop": {{
      "command": "tp",
      "args": ["mcp", "--repo", "{}"]
    }}
  }}
}}"#, repo_path.display());
    eprintln!();
    eprintln!("Available search tool parameters:");
    eprintln!("  â€¢ query (required): Natural language search query");
    eprintln!("  â€¢ limit: Maximum results (default: 10)");
    eprintln!("  â€¢ threshold: Similarity threshold (0.0-1.0)");
    eprintln!("  â€¢ filetype: File extension filter (e.g., '.rs', '.js')");
    eprintln!("  â€¢ filter: Glob pattern filter (e.g., 'src/**/*.rs')");
    eprintln!();
    eprintln!("Press Ctrl+C to stop the server");
    eprintln!();
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[test]
    fn test_mcp_args_validation() {
        let temp_dir = TempDir::new().unwrap();
        
        // Valid arguments
        let valid_args = McpArgs {
            repo: temp_dir.path().to_path_buf(),
            model: None,
            max_filesize: Some("1mb".to_string()),
            filter: Some("*.rs".to_string()),
            filetype: None,
            force_rebuild: false,
            verbose: false,
            debug: false,
        };
        assert!(valid_args.validate().is_ok());
        
        // Invalid repository path
        let invalid_repo = McpArgs {
            repo: "/nonexistent/path".into(),
            model: None,
            max_filesize: None,
            filter: None,
            filetype: None,
            force_rebuild: false,
            verbose: false,
            debug: false,
        };
        assert!(invalid_repo.validate().is_err());
        
        // Invalid file size
        let invalid_size = McpArgs {
            repo: temp_dir.path().to_path_buf(),
            model: None,
            max_filesize: Some("invalid_size".to_string()),
            filter: None,
            filetype: None,
            force_rebuild: false,
            verbose: false,
            debug: false,
        };
        assert!(invalid_size.validate().is_err());
        
        // Invalid glob pattern
        let invalid_glob = McpArgs {
            repo: temp_dir.path().to_path_buf(),
            model: None,
            max_filesize: None,
            filter: Some("[invalid".to_string()),
            filetype: None,
            force_rebuild: false,
            verbose: false,
            debug: false,
        };
        assert!(invalid_glob.validate().is_err());
    }
    
    #[test]
    fn test_config_overrides() {
        let temp_dir = TempDir::new().unwrap();
        let mut config = TurboPropConfig::default();
        
        let args = McpArgs {
            repo: temp_dir.path().to_path_buf(),
            model: Some("custom-model".to_string()),
            max_filesize: Some("5mb".to_string()),
            filter: Some("src/**/*.rs".to_string()),
            filetype: Some("rust".to_string()),
            force_rebuild: true,
            verbose: false,
            debug: false,
        };
        
        apply_config_overrides(&mut config, &args).unwrap();
        
        assert_eq!(config.embedding.model, "custom-model");
        assert_eq!(config.file_discovery.max_filesize.as_bytes(), 5 * 1024 * 1024);
        assert_eq!(config.file_discovery.include_patterns, vec!["src/**/*.rs"]);
        assert_eq!(config.file_discovery.file_types, Some(vec!["rust".to_string()]));
        assert!(config.indexing.force_rebuild);
    }
}
```

### 3. Update Commands Module

Update `src/commands/mod.rs` to include the MCP command:
```rust
// Add to existing mod.rs file

pub mod mcp;

// Re-export for convenience
pub use mcp::execute_mcp_command;
```

### 4. Update Main Binary

Update `src/main.rs` to handle the MCP command:
```rust
// Add to existing main.rs file

use turboprop::cli::{Cli, Commands};
use turbroprop::commands::execute_mcp_command;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    
    match cli.command {
        // ... existing command handlers ...
        
        Commands::Mcp(args) => {
            // Print setup information
            crate::commands::mcp::print_setup_info(&args.repo);
            
            // Execute MCP server
            execute_mcp_command(args).await?;
        }
    }
    
    Ok(())
}
```

### 5. Add Help Text and Examples

Add comprehensive help text by updating the CLI documentation:
```rust
// Add to cli.rs

/// TurboProp - Fast Semantic Code Search and Indexing
/// 
/// TurboProp provides semantic search capabilities for codebases using ML embeddings.
/// It can run as a CLI tool or as an MCP server for integration with coding agents.
/// 
/// Examples:
///   tp index --repo .                    Index the current directory
///   tp search "authentication code"      Search for authentication-related code
///   tp mcp --repo .                      Start MCP server for current directory
///   tp mcp --repo . --model qwen3        Start MCP server with specific model
/// 
/// For more information, visit: https://github.com/turboprop-org/turboprop
#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    // ... existing fields ...
}
```

## Files to Create/Modify
- `src/cli.rs` - Add MCP command and arguments
- `src/commands/mcp.rs` - MCP command implementation  
- `src/commands/mod.rs` - Export MCP command
- `src/main.rs` - Handle MCP command in main

## Acceptance Criteria
- [ ] `tp mcp` command is available and documented
- [ ] All relevant CLI arguments are supported with proper validation
- [ ] Configuration loading and overrides work correctly
- [ ] Logging is properly configured to stderr (not stdout)
- [ ] Help text provides clear guidance for users
- [ ] Command integrates cleanly with existing CLI structure
- [ ] Error handling provides meaningful error messages
- [ ] Unit tests cover argument validation and configuration

## Success Validation
```bash
# Verify the command is available
cargo build --release
./target/release/tp mcp --help

# Test argument validation
./target/release/tp mcp --repo /nonexistent 2>&1 | grep -q "does not exist"

# Test configuration loading
./target/release/tp mcp --repo . --verbose --max-filesize 1mb --model test-model

# Run unit tests
cargo test commands::mcp
cargo test test_mcp_args_validation
```

## Notes
This step adds the CLI interface for the MCP server by:
- Creating a comprehensive command structure with proper argument validation
- Integrating with existing TurboProp configuration loading
- Adding detailed help text and examples for user guidance
- Ensuring proper logging setup that doesn't interfere with MCP protocol
- Providing clear setup instructions for coding agent integration

The CLI command provides a simple interface (`tp mcp --repo .`) while supporting all the configuration options users might need for different scenarios. The implementation follows TurboProp's existing CLI patterns and maintains consistency with other commands.