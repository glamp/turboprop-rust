# Step 33: Comprehensive Testing and Integration Tests

## Objective
Create comprehensive unit and integration tests for the MCP server implementation, following TurboProp's two-tier testing methodology.

## Background
Following TurboProp's established testing pattern, we need both fast unit tests (for daily development) and slow integration tests (for comprehensive validation). The MCP server introduces new components that need thorough testing to ensure reliability and correctness.

## Tasks
1. Create fast unit tests for all MCP components
2. Add integration tests for end-to-end MCP functionality
3. Create MCP-specific test utilities and fixtures
4. Add binary integration tests for the `tp mcp` command
5. Ensure tests follow TurboProp's testing patterns

## Implementation Details

### 1. Create MCP Unit Tests

Create `tests/mcp_unit_tests.rs`:
```rust
//! Fast unit tests for MCP components
//!
//! These tests provide quick feedback during development and are part of
//! the default `cargo test` suite.

use anyhow::Result;
use serde_json::{json, Value};
use std::path::PathBuf;
use tempfile::TempDir;
use tokio::time::{timeout, Duration};

use turboprop::config::TurboPropConfig;
use turboprop::mcp::{
    index_manager::{IndexManager, IndexStats},
    protocol::{
        constants, InitializeParams, InitializeResult, JsonRpcError, JsonRpcRequest, JsonRpcResponse,
        ClientInfo, ClientCapabilities, ServerInfo, ServerCapabilities
    },
    server::{McpServer, McpServerBuilder},
    tools::{SearchTool, SearchToolParams},
    transport::{StdioTransport, RequestValidator},
};

mod common;
use common::create_test_repository;

/// Test MCP protocol message serialization/deserialization
mod protocol_tests {
    use super::*;
    
    #[test]
    fn test_json_rpc_request_validation() {
        // Valid request
        let valid_request = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(1),
            method: "initialize".to_string(),
            params: Some(json!({})),
        };
        assert!(RequestValidator::validate(&valid_request).is_ok());
        
        // Invalid JSON-RPC version
        let invalid_version = JsonRpcRequest {
            jsonrpc: "1.0".to_string(),
            id: json!(1),
            method: "initialize".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&invalid_version).is_err());
        
        // Null ID (not allowed)
        let null_id = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(null),
            method: "initialize".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&null_id).is_err());
        
        // Empty method
        let empty_method = JsonRpcRequest {
            jsonrpc: "2.0".to_string(),
            id: json!(1),
            method: "".to_string(),
            params: None,
        };
        assert!(RequestValidator::validate(&empty_method).is_err());
    }
    
    #[test]
    fn test_initialize_params_deserialization() {
        let params_json = json!({
            "protocolVersion": "2024-11-05",
            "clientInfo": {
                "name": "test-client",
                "version": "1.0.0"
            },
            "capabilities": {
                "experimental": {}
            }
        });
        
        let params: InitializeParams = serde_json::from_value(params_json).unwrap();
        
        assert_eq!(params.protocol_version, "2024-11-05");
        assert_eq!(params.client_info.name, "test-client");
        assert_eq!(params.client_info.version, "1.0.0");
    }
    
    #[test]
    fn test_error_response_creation() {
        let error = JsonRpcError::method_not_found("unknown_method".to_string());
        let response = JsonRpcResponse::error(json!(123), error);
        
        assert_eq!(response.jsonrpc, "2.0");
        assert_eq!(response.id, json!(123));
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        
        let error_obj = response.error.unwrap();
        assert_eq!(error_obj.code, -32601);
        assert!(error_obj.message.contains("unknown_method"));
    }
    
    #[test]
    fn test_protocol_constants() {
        assert_eq!(constants::PROTOCOL_VERSION, "2024-11-05");
        assert_eq!(constants::SERVER_NAME, "turboprop");
        assert!(!constants::SERVER_VERSION.is_empty());
        
        assert_eq!(constants::methods::INITIALIZE, "initialize");
        assert_eq!(constants::methods::TOOLS_LIST, "tools/list");
        assert_eq!(constants::methods::TOOLS_CALL, "tools/call");
    }
}

/// Test search tool functionality
mod search_tool_tests {
    use super::*;
    
    #[test]
    fn test_search_tool_creation() {
        let tool = SearchTool::new();
        
        assert_eq!(tool.name, "search");
        assert!(!tool.description.is_empty());
        assert!(tool.input_schema.is_object());
        
        // Verify schema structure
        let schema = &tool.input_schema;
        assert!(schema["properties"]["query"].is_object());
        assert!(schema["properties"]["limit"].is_object());
        assert!(schema["properties"]["threshold"].is_object());
        
        let required = schema["required"].as_array().unwrap();
        assert!(required.contains(&json!("query")));
    }
    
    #[test]
    fn test_search_params_validation() {
        let tool = SearchTool::new();
        
        // Valid parameters
        let valid_params = SearchToolParams {
            query: "test query".to_string(),
            limit: 10,
            threshold: Some(0.5),
            filetype: Some(".rs".to_string()),
            filter: Some("src/**/*.rs".to_string()),
            include_content: Some(true),
            context_lines: Some(2),
        };
        assert!(tool.validate_params(&valid_params).is_ok());
        
        // Empty query
        let empty_query = SearchToolParams {
            query: "".to_string(),
            limit: 10,
            threshold: None,
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&empty_query).is_err());
        
        // Query too long
        let long_query = SearchToolParams {
            query: "x".repeat(1001),
            limit: 10,
            threshold: None,
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&long_query).is_err());
        
        // Limit too high
        let high_limit = SearchToolParams {
            query: "test".to_string(),
            limit: 200,
            threshold: None,
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&high_limit).is_err());
        
        // Invalid threshold
        let invalid_threshold = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: Some(1.5),
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&invalid_threshold).is_err());
        
        // Invalid filetype format
        let invalid_filetype = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: None,
            filetype: Some("rs".to_string()), // missing dot
            filter: None,
            include_content: None,
            context_lines: None,
        };
        assert!(tool.validate_params(&invalid_filetype).is_err());
        
        // Too many context lines
        let too_many_context = SearchToolParams {
            query: "test".to_string(),
            limit: 10,
            threshold: None,
            filetype: None,
            filter: None,
            include_content: None,
            context_lines: Some(15),
        };
        assert!(tool.validate_params(&too_many_context).is_err());
    }
    
    #[test]
    fn test_search_params_deserialization() {
        // Minimal parameters
        let minimal_params = json!({
            "query": "test function"
        });
        
        let params: SearchToolParams = serde_json::from_value(minimal_params).unwrap();
        assert_eq!(params.query, "test function");
        assert_eq!(params.limit, 10); // default
        assert_eq!(params.threshold, None);
        
        // Full parameters
        let full_params = json!({
            "query": "authentication code",
            "limit": 20,
            "threshold": 0.8,
            "filetype": ".py",
            "filter": "src/**/*.py",
            "include_content": false,
            "context_lines": 3
        });
        
        let params: SearchToolParams = serde_json::from_value(full_params).unwrap();
        assert_eq!(params.query, "authentication code");
        assert_eq!(params.limit, 20);
        assert_eq!(params.threshold, Some(0.8));
        assert_eq!(params.filetype, Some(".py".to_string()));
        assert_eq!(params.filter, Some("src/**/*.py".to_string()));
        assert_eq!(params.include_content, Some(false));
        assert_eq!(params.context_lines, Some(3));
    }
}

/// Test MCP server functionality (without actual indexing)
mod server_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_mcp_server_creation() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let server = McpServer::new(temp_dir.path(), &config).await;
        assert!(server.is_ok());
    }
    
    #[tokio::test]
    async fn test_mcp_server_builder() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let server = McpServerBuilder::new()
            .repo_path(temp_dir.path())
            .config(config)
            .build()
            .await;
        
        assert!(server.is_ok());
    }
    
    #[tokio::test]
    async fn test_initialize_request_handling() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(1),
            constants::methods::INITIALIZE.to_string(),
            Some(json!({
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {
                    "name": "test-client",
                    "version": "1.0.0"
                },
                "capabilities": {}
            }))
        );
        
        let response = server.handle_initialize(request).await;
        
        assert!(response.error.is_none());
        assert!(response.result.is_some());
        
        let result = response.result.unwrap();
        assert_eq!(result["protocolVersion"], constants::PROTOCOL_VERSION);
        assert_eq!(result["serverInfo"]["name"], constants::SERVER_NAME);
        assert_eq!(result["serverInfo"]["version"], constants::SERVER_VERSION);
        
        // Check capabilities
        assert!(result["capabilities"]["tools"].is_object());
    }
    
    #[tokio::test]
    async fn test_tools_list_request_handling() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(2),
            constants::methods::TOOLS_LIST.to_string(),
            None
        );
        
        let response = server.handle_tools_list(request).await;
        
        assert!(response.error.is_none());
        assert!(response.result.is_some());
        
        let result = response.result.unwrap();
        let tools = result["tools"].as_array().unwrap();
        assert_eq!(tools.len(), 1);
        assert_eq!(tools[0]["name"], "search");
        assert!(tools[0]["description"].is_string());
        assert!(tools[0]["inputSchema"].is_object());
    }
    
    #[tokio::test]
    async fn test_invalid_method_handling() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        let request = JsonRpcRequest::new(
            json!(3),
            "invalid_method".to_string(),
            None
        );
        
        let response = server.handle_request(request).await;
        
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        
        let error = response.error.unwrap();
        assert_eq!(error.code, -32601); // Method not found
        assert!(error.message.contains("invalid_method"));
    }
    
    #[tokio::test]
    async fn test_malformed_request_handling() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        let server = McpServer::new(temp_dir.path(), &config).await.unwrap();
        
        // Request with invalid JSON-RPC version
        let request = JsonRpcRequest {
            jsonrpc: "1.0".to_string(),
            id: json!(4),
            method: "initialize".to_string(),
            params: None,
        };
        
        let response = server.handle_request(request).await;
        
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        assert_eq!(response.error.unwrap().code, -32600); // Invalid request
    }
}

/// Test index manager functionality (without actual file watching)
mod index_manager_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_index_manager_creation() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let manager = IndexManager::new(temp_dir.path(), &config, None).await;
        assert!(manager.is_ok());
    }
    
    #[tokio::test]
    async fn test_index_stats_tracking() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let manager = IndexManager::new(temp_dir.path(), &config, None).await.unwrap();
        let stats = manager.get_stats().await;
        
        assert_eq!(stats.total_chunks, 0);
        assert_eq!(stats.total_files, 0);
        assert_eq!(stats.updates_processed, 0);
        assert_eq!(stats.files_added, 0);
        assert_eq!(stats.files_updated, 0);
        assert_eq!(stats.files_removed, 0);
        assert_eq!(stats.update_errors, 0);
        assert!(stats.last_update.is_none());
    }
    
    #[tokio::test]
    async fn test_index_manager_shutdown() {
        let temp_dir = TempDir::new().unwrap();
        let config = TurboPropConfig::default();
        
        let mut manager = IndexManager::new(temp_dir.path(), &config, None).await.unwrap();
        
        // Start and stop should not error
        assert!(manager.start().await.is_ok());
        assert!(manager.stop().await.is_ok());
    }
}

/// Test transport functionality
mod transport_tests {
    use super::*;
    
    #[tokio::test]
    async fn test_transport_creation() {
        let (transport, _response_rx) = StdioTransport::new();
        
        // Transport should be created successfully
        drop(transport);
    }
    
    #[test]
    fn test_error_response_creation() {
        let error = JsonRpcError::internal_error("test error".to_string());
        let response = StdioTransport::create_error_response(Some(json!(42)), error);
        
        assert_eq!(response.id, json!(42));
        assert!(response.result.is_none());
        assert!(response.error.is_some());
        assert_eq!(response.error.unwrap().message, "test error");
    }
}
```

### 2. Create Integration Tests

Create `tests/integration/mcp_tests.rs`:
```rust
//! Integration tests for MCP server functionality
//!
//! These tests validate end-to-end MCP functionality and are part of
//! the slow test suite (`cargo test --test integration`).

use anyhow::Result;
use serde_json::{json, Value};
use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader, Write};
use std::time::Duration;
use tempfile::TempDir;
use tokio::time::timeout;

use turboprop::config::TurboPropConfig;
use turboprop::mcp::{McpServer, protocol::constants};

/// Test utilities for MCP integration tests
mod test_utils {
    use super::*;
    
    /// Create a test repository with sample files
    pub fn create_test_repo() -> TempDir {
        let temp_dir = TempDir::new().unwrap();
        
        // Create sample files
        std::fs::create_dir_all(temp_dir.path().join("src")).unwrap();
        std::fs::write(
            temp_dir.path().join("src/main.rs"),
            r#"
fn main() {
    println!("Hello, world!");
}

fn authenticate_user(username: &str, password: &str) -> bool {
    // Simple authentication logic
    username == "admin" && password == "secret"
}

fn calculate_total(items: &[f64]) -> f64 {
    items.iter().sum()
}
"#,
        ).unwrap();
        
        std::fs::write(
            temp_dir.path().join("src/lib.rs"),
            r#"
/// JWT token validation function
pub fn validate_jwt_token(token: &str) -> Result<bool, String> {
    if token.is_empty() {
        return Err("Token cannot be empty".to_string());
    }
    
    // Mock validation logic
    Ok(token.starts_with("eyJ"))
}

/// Error handling utilities
pub mod error {
    pub fn handle_database_error(err: &str) -> String {
        format!("Database error: {}", err)
    }
}
"#,
        ).unwrap();
        
        std::fs::write(
            temp_dir.path().join("README.md"),
            r#"# Test Project

This is a test project for TurboProp MCP server testing.

## Features

- User authentication
- JWT token validation
- Error handling
- Mathematical calculations
"#,
        ).unwrap();
        
        temp_dir
    }
    
    /// Send a JSON-RPC request and receive response
    pub async fn send_mcp_request(
        process: &mut std::process::Child,
        request: Value,
    ) -> Result<Value> {
        let stdin = process.stdin.as_mut().unwrap();
        let request_str = format!("{}\n", serde_json::to_string(&request)?);
        stdin.write_all(request_str.as_bytes())?;
        stdin.flush()?;
        
        // Read response
        let stdout = process.stdout.as_mut().unwrap();
        let mut reader = BufReader::new(stdout);
        let mut response_line = String::new();
        reader.read_line(&mut response_line)?;
        
        let response: Value = serde_json::from_str(&response_line)?;
        Ok(response)
    }
}

/// Test MCP server binary integration
mod binary_tests {
    use super::*;
    use test_utils::*;
    
    #[tokio::test]
    async fn test_mcp_binary_startup() {
        let test_repo = create_test_repo();
        
        // Start MCP server process
        let mut child = Command::new("cargo")
            .args(&["run", "--bin", "tp", "--", "mcp", "--repo"])
            .arg(test_repo.path())
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .expect("Failed to start tp mcp command");
        
        // Give the server time to start
        tokio::time::sleep(Duration::from_millis(1000)).await;
        
        // Send initialize request
        let initialize_request = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {
                    "name": "test-client",
                    "version": "1.0.0"
                },
                "capabilities": {}
            }
        });
        
        let response = timeout(
            Duration::from_secs(10),
            send_mcp_request(&mut child, initialize_request)
        ).await
        .expect("Request timed out")
        .expect("Failed to send request");
        
        // Verify response
        assert_eq!(response["jsonrpc"], "2.0");
        assert_eq!(response["id"], 1);
        assert!(response["error"].is_null());
        assert_eq!(response["result"]["protocolVersion"], constants::PROTOCOL_VERSION);
        assert_eq!(response["result"]["serverInfo"]["name"], constants::SERVER_NAME);
        
        // Cleanup
        child.kill().expect("Failed to kill child process");
    }
    
    #[tokio::test]
    async fn test_tools_list_integration() {
        let test_repo = create_test_repo();
        
        let mut child = Command::new("cargo")
            .args(&["run", "--bin", "tp", "--", "mcp", "--repo"])
            .arg(test_repo.path())
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .expect("Failed to start tp mcp command");
        
        tokio::time::sleep(Duration::from_millis(1000)).await;
        
        // Initialize first
        let initialize_request = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {"name": "test", "version": "1.0"},
                "capabilities": {}
            }
        });
        
        let _ = send_mcp_request(&mut child, initialize_request).await.unwrap();
        
        // Request tools list
        let tools_request = json!({
            "jsonrpc": "2.0",
            "id": 2,
            "method": "tools/list"
        });
        
        let response = timeout(
            Duration::from_secs(5),
            send_mcp_request(&mut child, tools_request)
        ).await
        .expect("Request timed out")
        .expect("Failed to send request");
        
        // Verify response
        assert_eq!(response["jsonrpc"], "2.0");
        assert_eq!(response["id"], 2);
        assert!(response["error"].is_null());
        
        let tools = response["result"]["tools"].as_array().unwrap();
        assert_eq!(tools.len(), 1);
        assert_eq!(tools[0]["name"], "search");
        assert!(tools[0]["inputSchema"].is_object());
        
        child.kill().expect("Failed to kill child process");
    }
    
    #[tokio::test]
    async fn test_search_tool_integration() {
        let test_repo = create_test_repo();
        
        let mut child = Command::new("cargo")
            .args(&["run", "--bin", "tp", "--", "mcp", "--repo"])
            .arg(test_repo.path())
            .arg("--force-rebuild")
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .expect("Failed to start tp mcp command");
        
        // Give server more time to index files
        tokio::time::sleep(Duration::from_millis(5000)).await;
        
        // Initialize
        let initialize_request = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {"name": "test", "version": "1.0"},
                "capabilities": {}
            }
        });
        let _ = send_mcp_request(&mut child, initialize_request).await.unwrap();
        
        // Wait a bit more for indexing to complete
        tokio::time::sleep(Duration::from_millis(2000)).await;
        
        // Execute search
        let search_request = json!({
            "jsonrpc": "2.0",
            "id": 3,
            "method": "tools/call",
            "params": {
                "name": "search",
                "arguments": {
                    "query": "authentication",
                    "limit": 5
                }
            }
        });
        
        let response = timeout(
            Duration::from_secs(10),
            send_mcp_request(&mut child, search_request)
        ).await
        .expect("Request timed out")
        .expect("Failed to send request");
        
        // Verify response structure (results may vary based on indexing)
        assert_eq!(response["jsonrpc"], "2.0");
        assert_eq!(response["id"], 3);
        
        // Check if we got results or an appropriate error
        if response["error"].is_null() {
            let result = &response["result"];
            assert!(result["results"].is_array());
            assert!(result["total_results"].is_number());
            assert!(result["execution_time_ms"].is_number());
        } else {
            // If indexing isn't complete, we should get an appropriate error
            let error = &response["error"];
            assert!(error["code"].is_number());
            assert!(error["message"].is_string());
        }
        
        child.kill().expect("Failed to kill child process");
    }
}

/// Test library-level MCP server functionality
mod library_tests {
    use super::*;
    use test_utils::*;
    
    #[tokio::test]
    async fn test_mcp_server_library_usage() {
        let test_repo = create_test_repo();
        let config = TurboPropConfig::default();
        
        // Create server
        let server = McpServer::new(test_repo.path(), &config).await
            .expect("Failed to create MCP server");
        
        // Test initialization request
        let init_request = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "initialize",
            "params": {
                "protocolVersion": constants::PROTOCOL_VERSION,
                "clientInfo": {"name": "test", "version": "1.0"},
                "capabilities": {}
            }
        });
        
        let request = serde_json::from_value(init_request).unwrap();
        let response = server.handle_initialize(request).await;
        
        assert!(response.error.is_none());
        assert!(response.result.is_some());
    }
    
    #[tokio::test]
    async fn test_concurrent_requests() {
        let test_repo = create_test_repo();
        let config = TurboPropConfig::default();
        
        let server = McpServer::new(test_repo.path(), &config).await
            .expect("Failed to create MCP server");
        
        // Send multiple concurrent requests
        let mut handles = Vec::new();
        
        for i in 0..5 {
            let server_clone = &server; // Server is behind Arc internally
            let handle = tokio::spawn(async move {
                let request = json!({
                    "jsonrpc": "2.0",
                    "id": i,
                    "method": "tools/list"
                });
                
                let request = serde_json::from_value(request).unwrap();
                server_clone.handle_tools_list(request).await
            });
            handles.push(handle);
        }
        
        // Wait for all requests to complete
        for handle in handles {
            let response = handle.await.unwrap();
            assert!(response.error.is_none());
            assert!(response.result.is_some());
        }
    }
}
```

### 3. Add MCP Test Utilities

Create `tests/mcp_common.rs`:
```rust
//! Common utilities for MCP testing

use anyhow::Result;
use serde_json::{json, Value};
use std::path::Path;
use tempfile::TempDir;

use turboprop::config::TurboPropConfig;
use turboprop::mcp::protocol::constants;

/// Create a test repository with sample code files
pub fn create_test_repository() -> TempDir {
    let temp_dir = TempDir::new().unwrap();
    let root = temp_dir.path();
    
    // Create directory structure
    std::fs::create_dir_all(root.join("src")).unwrap();
    std::fs::create_dir_all(root.join("tests")).unwrap();
    std::fs::create_dir_all(root.join("docs")).unwrap();
    
    // Create sample Rust files
    std::fs::write(
        root.join("src/main.rs"),
        r#"//! Main application entry point

use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    let config = load_config()?;
    let auth = setup_authentication(&config)?;
    
    run_application(auth).await
}

fn load_config() -> Result<Config, ConfigError> {
    Config::from_file("config.toml")
}

fn setup_authentication(config: &Config) -> Result<AuthService, AuthError> {
    AuthService::new(config.auth_config())
}

async fn run_application(auth: AuthService) -> Result<(), AppError> {
    let server = HttpServer::new(auth);
    server.listen("0.0.0.0:8080").await
}
"#,
    ).unwrap();
    
    std::fs::write(
        root.join("src/auth.rs"),
        r#"//! Authentication and authorization module

use std::collections::HashMap;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: u64,
    pub username: String,
    pub email: String,
    pub role: UserRole,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserRole {
    Admin,
    User,
    Guest,
}

pub struct AuthService {
    users: HashMap<String, User>,
    jwt_secret: String,
}

impl AuthService {
    pub fn new(config: AuthConfig) -> Result<Self, AuthError> {
        Ok(Self {
            users: HashMap::new(),
            jwt_secret: config.jwt_secret,
        })
    }
    
    pub fn authenticate_user(&self, username: &str, password: &str) -> Result<User, AuthError> {
        if let Some(user) = self.users.get(username) {
            if self.verify_password(password, &user.username) {
                Ok(user.clone())
            } else {
                Err(AuthError::InvalidCredentials)
            }
        } else {
            Err(AuthError::UserNotFound)
        }
    }
    
    pub fn generate_jwt_token(&self, user: &User) -> Result<String, AuthError> {
        // Mock JWT generation
        Ok(format!("eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.{}.signature", user.id))
    }
    
    pub fn validate_jwt_token(&self, token: &str) -> Result<User, AuthError> {
        if token.starts_with("eyJ") {
            // Mock validation - in real code, properly verify JWT
            let user_id = self.extract_user_id_from_token(token)?;
            self.get_user_by_id(user_id)
        } else {
            Err(AuthError::InvalidToken)
        }
    }
    
    fn verify_password(&self, password: &str, username: &str) -> bool {
        // Mock password verification
        !password.is_empty() && !username.is_empty()
    }
    
    fn extract_user_id_from_token(&self, token: &str) -> Result<u64, AuthError> {
        // Mock extraction
        Ok(1)
    }
    
    fn get_user_by_id(&self, id: u64) -> Result<User, AuthError> {
        // Mock user lookup
        Ok(User {
            id,
            username: "test_user".to_string(),
            email: "test@example.com".to_string(),
            role: UserRole::User,
        })
    }
}

#[derive(Debug)]
pub enum AuthError {
    InvalidCredentials,
    UserNotFound,
    InvalidToken,
    TokenExpired,
}
"#,
    ).unwrap();
    
    std::fs::write(
        root.join("src/utils.rs"),
        r#"//! Utility functions and error handling

use std::fmt;

/// Calculate the total of a list of numbers
pub fn calculate_total(numbers: &[f64]) -> f64 {
    numbers.iter().sum()
}

/// Format error messages consistently
pub fn format_error_message(context: &str, error: &dyn std::error::Error) -> String {
    format!("Error in {}: {}", context, error)
}

/// Handle database connection errors
pub fn handle_database_error(error: DatabaseError) -> Result<(), AppError> {
    match error {
        DatabaseError::ConnectionFailed => {
            log::error!("Database connection failed");
            Err(AppError::DatabaseUnavailable)
        }
        DatabaseError::QueryTimeout => {
            log::warn!("Database query timed out");
            Err(AppError::RequestTimeout)
        }
        DatabaseError::InvalidQuery => {
            log::error!("Invalid database query");
            Err(AppError::InternalError)
        }
    }
}

#[derive(Debug)]
pub enum DatabaseError {
    ConnectionFailed,
    QueryTimeout,
    InvalidQuery,
}

#[derive(Debug)]
pub enum AppError {
    DatabaseUnavailable,
    RequestTimeout,
    InternalError,
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::DatabaseUnavailable => write!(f, "Database is unavailable"),
            AppError::RequestTimeout => write!(f, "Request timed out"),
            AppError::InternalError => write!(f, "Internal error occurred"),
        }
    }
}

impl std::error::Error for AppError {}
"#,
    ).unwrap();
    
    // Create test files
    std::fs::write(
        root.join("tests/auth_tests.rs"),
        r#"//! Tests for authentication module

use myapp::auth::{AuthService, User, UserRole, AuthError};

#[test]
fn test_user_authentication() {
    let auth = create_test_auth_service();
    
    let result = auth.authenticate_user("testuser", "password123");
    assert!(result.is_ok());
    
    let user = result.unwrap();
    assert_eq!(user.username, "testuser");
}

#[test]
fn test_jwt_token_validation() {
    let auth = create_test_auth_service();
    let user = create_test_user();
    
    let token = auth.generate_jwt_token(&user).unwrap();
    let validated_user = auth.validate_jwt_token(&token).unwrap();
    
    assert_eq!(validated_user.id, user.id);
}

fn create_test_auth_service() -> AuthService {
    // Create test auth service
    AuthService::new(create_test_config()).unwrap()
}

fn create_test_user() -> User {
    User {
        id: 1,
        username: "testuser".to_string(),
        email: "test@example.com".to_string(),
        role: UserRole::User,
    }
}
"#,
    ).unwrap();
    
    // Create documentation
    std::fs::write(
        root.join("docs/API.md"),
        r#"# API Documentation

## Authentication Endpoints

### POST /auth/login

Authenticate a user with username and password.

**Request Body:**
```json
{
  "username": "string",
  "password": "string"
}
```

**Response:**
```json
{
  "token": "jwt_token_string",
  "user": {
    "id": 123,
    "username": "string",
    "email": "string",
    "role": "User"
  }
}
```

### POST /auth/validate

Validate a JWT token.

**Headers:**
```
Authorization: Bearer jwt_token_string
```

**Response:**
```json
{
  "valid": true,
  "user": {
    "id": 123,
    "username": "string",
    "email": "string",
    "role": "User"
  }
}
```

## Error Handling

All endpoints return consistent error responses:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable error message"
  }
}
```

Common error codes:
- `INVALID_CREDENTIALS`: Authentication failed
- `TOKEN_EXPIRED`: JWT token has expired
- `USER_NOT_FOUND`: User does not exist
- `INTERNAL_ERROR`: Server error occurred
"#,
    ).unwrap();
    
    // Create configuration file
    std::fs::write(
        root.join(".turboprop.yml"),
        r#"# TurboProp configuration for test repository
max_filesize: "2mb"
model: "sentence-transformers/all-MiniLM-L6-v2"
default_limit: 10
similarity_threshold: 0.3

file_discovery:
  include_patterns:
    - "**/*.rs"
    - "**/*.md"
  exclude_patterns:
    - "target/**"
    - ".git/**"
"#,
    ).unwrap();
    
    temp_dir
}

/// Create a test configuration
pub fn create_test_config() -> TurboPropConfig {
    let mut config = TurboPropConfig::default();
    config.embedding.model = "sentence-transformers/all-MiniLM-L6-v2".to_string();
    config.search.default_limit = 10;
    config
}

/// Create a standard initialize request for testing
pub fn create_initialize_request(id: u64) -> Value {
    json!({
        "jsonrpc": "2.0",
        "id": id,
        "method": constants::methods::INITIALIZE,
        "params": {
            "protocolVersion": constants::PROTOCOL_VERSION,
            "clientInfo": {
                "name": "test-client",
                "version": "1.0.0"
            },
            "capabilities": {}
        }
    })
}

/// Create a tools/list request for testing
pub fn create_tools_list_request(id: u64) -> Value {
    json!({
        "jsonrpc": "2.0",
        "id": id,
        "method": constants::methods::TOOLS_LIST
    })
}

/// Create a search tool call request for testing
pub fn create_search_request(id: u64, query: &str, limit: Option<usize>) -> Value {
    let mut arguments = json!({
        "query": query
    });
    
    if let Some(limit) = limit {
        arguments["limit"] = json!(limit);
    }
    
    json!({
        "jsonrpc": "2.0",
        "id": id,
        "method": constants::methods::TOOLS_CALL,
        "params": {
            "name": "search",
            "arguments": arguments
        }
    })
}

/// Assert that a JSON-RPC response is successful
pub fn assert_successful_response(response: &Value, expected_id: u64) {
    assert_eq!(response["jsonrpc"], "2.0");
    assert_eq!(response["id"], expected_id);
    assert!(response["error"].is_null());
    assert!(response["result"].is_object());
}

/// Assert that a JSON-RPC response contains an error
pub fn assert_error_response(response: &Value, expected_id: u64, expected_code: i32) {
    assert_eq!(response["jsonrpc"], "2.0");
    assert_eq!(response["id"], expected_id);
    assert!(response["result"].is_null());
    assert!(response["error"].is_object());
    assert_eq!(response["error"]["code"], expected_code);
    assert!(response["error"]["message"].is_string());
}
```

### 4. Update Test Configuration

Update `test_config.toml` to include MCP test settings:
```toml
# Test configuration for MCP functionality

[embedding]
model = "sentence-transformers/all-MiniLM-L6-v2"
batch_size = 8

[search]
default_limit = 10
similarity_threshold = 0.3

[file_discovery]
max_filesize = "1mb"
include_patterns = ["**/*.rs", "**/*.md"]

[mcp]
# MCP-specific test settings
enable_file_watching = true
update_debounce_ms = 100
max_concurrent_searches = 5
```

## Files to Create/Modify
- `tests/mcp_unit_tests.rs` - Fast unit tests for MCP components
- `tests/integration/mcp_tests.rs` - Slow integration tests
- `tests/mcp_common.rs` - Common test utilities
- `test_config.toml` - Add MCP test configuration

## Acceptance Criteria
- [ ] Fast unit tests cover all MCP protocol components
- [ ] Unit tests run in under 10 seconds as part of default test suite
- [ ] Integration tests validate end-to-end MCP functionality
- [ ] Binary integration tests verify `tp mcp` command works correctly
- [ ] Tests include both success and error scenarios
- [ ] Test utilities provide realistic repositories and scenarios
- [ ] All tests follow TurboProp's existing patterns and quality standards
- [ ] Tests achieve high code coverage for MCP modules

## Success Validation
```bash
# Run fast unit tests (default test suite)
cargo test mcp_unit_tests

# Verify tests complete quickly
time cargo test mcp_unit_tests  # Should be < 10 seconds

# Run slow integration tests
cargo test --test integration mcp_tests

# Test binary integration
cargo test --test integration binary_tests

# Run all MCP tests
cargo test mcp

# Check test coverage (if available)
cargo tarpaulin --include-tests --exclude-files "target/*" -- mcp
```

## Notes
This step creates comprehensive test coverage for the MCP server by:
- Following TurboProp's two-tier testing methodology (fast unit tests + slow integration tests)
- Testing all MCP protocol components with realistic scenarios
- Including binary integration tests that spawn actual `tp mcp` processes
- Creating reusable test utilities and fixtures for consistent testing
- Covering both success paths and error conditions thoroughly

The testing infrastructure ensures the MCP server implementation is robust, reliable, and maintains the high quality standards established by TurboProp. The tests provide confidence for future development and help catch regressions early.