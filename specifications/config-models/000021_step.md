# Step 21: Create Unified Model Interface for All Model Types

## Objective
Create a unified trait-based interface that abstracts over different model loading mechanisms (fastembed, GGUF, Hugging Face) to enable consistent embedding generation regardless of model type.

## Background
With three different model types (fastembed, GGUF, Hugging Face), we need a unified interface that allows the EmbeddingGenerator to work with any model type transparently. This step creates the trait definitions and infrastructure for loading different model types.

## Tasks
1. Define EmbeddingModel trait for unified model interface
2. Create model loading factory pattern
3. Implement trait for existing fastembed models
4. Add error types for different model loading scenarios
5. Create model loader infrastructure

## Implementation Details

### 1. Define Core Traits

#### EmbeddingModel Trait
```rust
use anyhow::Result;
use async_trait::async_trait;

/// Unified interface for all embedding models
#[async_trait]
pub trait EmbeddingModel: Send + Sync {
    /// Generate embeddings for a batch of texts
    async fn embed(&mut self, texts: &[&str]) -> Result<Vec<Vec<f32>>>;
    
    /// Get the embedding dimensions for this model
    fn embedding_dimensions(&self) -> usize;
    
    /// Get the model name/identifier
    fn model_name(&self) -> &str;
    
    /// Get the maximum context length this model supports
    fn context_length(&self) -> usize;
    
    /// Get model type
    fn model_type(&self) -> ModelType;
}
```

#### Model Loader Trait
```rust
/// Factory trait for loading different model types
#[async_trait]
pub trait ModelLoader: Send + Sync {
    /// Load a model of this type
    async fn load_model(
        &self,
        model_info: &ModelInfo,
        cache_dir: &Path,
    ) -> Result<Box<dyn EmbeddingModel>>;
    
    /// Check if this loader can handle the given model
    fn can_load(&self, model_type: ModelType) -> bool;
}
```

### 2. Create Error Types
```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ModelLoadingError {
    #[error("Model type {model_type:?} not supported")]
    UnsupportedModelType { model_type: ModelType },
    
    #[error("Failed to download model from {url}: {source}")]
    DownloadError { url: String, source: anyhow::Error },
    
    #[error("Invalid model file format: {message}")]
    InvalidFormat { message: String },
    
    #[error("Model initialization failed: {source}")]
    InitializationError { source: anyhow::Error },
    
    #[error("Tokenizer loading failed: {source}")]
    TokenizerError { source: anyhow::Error },
}
```

### 3. FastEmbed Model Wrapper
```rust
use fastembed::{TextEmbedding, InitOptions, EmbeddingModel as FastEmbedModel};

/// Wrapper around fastembed models to implement our trait
pub struct FastEmbedModelWrapper {
    model: TextEmbedding,
    model_name: String,
    dimensions: usize,
    context_length: usize,
}

#[async_trait]
impl EmbeddingModel for FastEmbedModelWrapper {
    async fn embed(&mut self, texts: &[&str]) -> Result<Vec<Vec<f32>>> {
        let embeddings = self.model.embed(texts.to_vec(), None)
            .map_err(|e| ModelLoadingError::InitializationError { source: e.into() })?;
        Ok(embeddings)
    }
    
    fn embedding_dimensions(&self) -> usize {
        self.dimensions
    }
    
    fn model_name(&self) -> &str {
        &self.model_name
    }
    
    fn context_length(&self) -> usize {
        self.context_length
    }
    
    fn model_type(&self) -> ModelType {
        ModelType::FastEmbed
    }
}
```

### 4. FastEmbed Loader Implementation
```rust
pub struct FastEmbedLoader;

#[async_trait]
impl ModelLoader for FastEmbedLoader {
    async fn load_model(
        &self,
        model_info: &ModelInfo,
        cache_dir: &Path,
    ) -> Result<Box<dyn EmbeddingModel>> {
        // Map model name to fastembed enum
        let fastembed_model = match model_info.name.as_str() {
            "sentence-transformers/all-MiniLM-L6-v2" => FastEmbedModel::AllMiniLML6V2,
            "sentence-transformers/all-MiniLM-L12-v2" => FastEmbedModel::AllMiniLML12V2,
            _ => return Err(ModelLoadingError::UnsupportedModelType {
                model_type: model_info.model_type.clone()
            }.into()),
        };
        
        let init_options = InitOptions::new(fastembed_model)
            .with_cache_dir(cache_dir);
            
        let model = TextEmbedding::try_new(init_options)
            .map_err(|e| ModelLoadingError::InitializationError { source: e.into() })?;
            
        Ok(Box::new(FastEmbedModelWrapper {
            model,
            model_name: model_info.name.clone(),
            dimensions: model_info.dimensions,
            context_length: model_info.metadata.context_length.unwrap_or(512),
        }))
    }
    
    fn can_load(&self, model_type: ModelType) -> bool {
        matches!(model_type, ModelType::FastEmbed)
    }
}
```

### 5. Model Loading Factory
```rust
/// Factory for loading models of any supported type
pub struct ModelFactory {
    loaders: Vec<Box<dyn ModelLoader>>,
}

impl Default for ModelFactory {
    fn default() -> Self {
        Self {
            loaders: vec![
                Box::new(FastEmbedLoader),
                // GGUF and HuggingFace loaders will be added in later steps
            ],
        }
    }
}

impl ModelFactory {
    /// Load a model by finding appropriate loader
    pub async fn load_model(
        &self,
        model_info: &ModelInfo,
        cache_dir: &Path,
    ) -> Result<Box<dyn EmbeddingModel>> {
        for loader in &self.loaders {
            if loader.can_load(model_info.model_type.clone()) {
                return loader.load_model(model_info, cache_dir).await;
            }
        }
        
        Err(ModelLoadingError::UnsupportedModelType {
            model_type: model_info.model_type.clone()
        }.into())
    }
}
```

### 6. Add async-trait Dependency
Update Cargo.toml:
```toml
async-trait = "0.1"
```

## Test Coverage
Add tests for:
- FastEmbed model wrapper functionality
- Model factory loading with supported models
- Error cases for unsupported models
- Trait object behavior and dynamic dispatch

## Acceptance Criteria
- [ ] EmbeddingModel trait defined with all required methods
- [ ] ModelLoader trait defined for factory pattern
- [ ] ModelLoadingError enum covers all error scenarios
- [ ] FastEmbedModelWrapper implements EmbeddingModel trait
- [ ] FastEmbedLoader implements ModelLoader trait
- [ ] ModelFactory provides unified loading interface
- [ ] async-trait dependency added to Cargo.toml
- [ ] All existing fastembed models work through new interface
- [ ] Comprehensive test coverage for trait implementations
- [ ] `cargo build` and `cargo test` succeed

## Files to Create/Modify
- `src/models.rs` - Add trait definitions and error types
- `src/models.rs` - Add FastEmbedModelWrapper and FastEmbedLoader
- `src/models.rs` - Add ModelFactory implementation
- `src/models.rs` - Add comprehensive test cases
- `Cargo.toml` - Add async-trait dependency

## Success Validation
```bash
cargo build
cargo test models::test_fastembed_wrapper
cargo test models::test_model_factory
cargo test models::test_model_loading_errors
```

## Notes
This step creates the foundation for unified model loading but only implements the fastembed path. GGUF and Hugging Face loaders will be added in subsequent steps. The trait-based design allows for easy extension to new model types in the future.

The async_trait is needed because we need async methods in traits, which isn't directly supported in stable Rust yet.