# Step 27: Update CLI and Configuration to Support New Models

## Objective
Update the command-line interface and configuration system to expose the new embedding models (nomic-embed-code.Q5_K_S.gguf and Qwen/Qwen3-Embedding-0.6B) to users, including help text, model selection, and configuration validation.

## Background
With the new models implemented, users need to be able to select and use them through the CLI. This step updates the CLI interface, help text, configuration options, and adds model listing functionality to make the new models accessible.

## Tasks
1. Update CLI to support new model names in configuration
2. Add model listing command to show available models
3. Update help text and examples with new models
4. Add model validation in CLI argument parsing
5. Update configuration files and environment variables
6. Add model information display functionality

## Implementation Details

### 1. Update CLI Model Configuration
```rust
// In src/cli.rs, update model-related arguments

#[derive(Debug, Parser)]
#[command(name = "tp")]
#[command(about = "Fast semantic code search and indexing tool")]
pub struct Cli {
    #[command(subcommand)]
    pub command: Commands,
    
    /// Embedding model to use for indexing and search
    #[arg(long, global = true, help = "Embedding model to use")]
    #[arg(long_help = "Embedding model to use for generating embeddings. 
Available models:
  - sentence-transformers/all-MiniLM-L6-v2 (default, 384 dims, ~23MB)
  - sentence-transformers/all-MiniLM-L12-v2 (384 dims, ~44MB)  
  - nomic-embed-code.Q5_K_S.gguf (768 dims, ~180MB, optimized for code)
  - Qwen/Qwen3-Embedding-0.6B (1024 dims, ~600MB, high accuracy)

Use 'tp models list' to see detailed information about available models.")]
    pub model: Option<String>,
}

#[derive(Debug, Subcommand)]
pub enum Commands {
    /// Initialize a new index for semantic search
    Index(IndexCommand),
    /// Search through indexed content
    Search(SearchCommand),
    /// Model management commands
    Models(ModelsCommand),
}

/// Model management commands
#[derive(Debug, Parser)]
pub struct ModelsCommand {
    #[command(subcommand)]
    pub action: ModelsAction,
}

#[derive(Debug, Subcommand)]
pub enum ModelsAction {
    /// List all available embedding models
    List,
    /// Show detailed information about a specific model
    Info {
        /// Model name to show information for
        model_name: String,
    },
    /// Download and cache a model
    Download {
        /// Model name to download
        model_name: String,
    },
    /// Remove a cached model
    Remove {
        /// Model name to remove from cache
        model_name: String,
    },
    /// Show cache statistics
    Cache,
}
```

### 2. Implement Model Management Commands
```rust
// In src/commands/mod.rs, add models module
pub mod models;

// Create src/commands/models.rs
use anyhow::Result;
use crate::models::{ModelManager, ModelInfo, ModelType};
use crate::embeddings::EmbeddingGenerator;
use crate::cli::ModelsAction;
use tracing::info;

/// Execute model management commands
pub async fn execute_models_command(action: ModelsAction) -> Result<()> {
    match action {
        ModelsAction::List => list_models().await,
        ModelsAction::Info { model_name } => show_model_info(&model_name).await,
        ModelsAction::Download { model_name } => download_model(&model_name).await,
        ModelsAction::Remove { model_name } => remove_model(&model_name).await,
        ModelsAction::Cache => show_cache_stats().await,
    }
}

/// List all available models
async fn list_models() -> Result<()> {
    let models = ModelManager::get_available_models();
    
    println!("Available Embedding Models:");
    println!("{:<35} {:<12} {:<8} {:<10} {:<20}", "Name", "Type", "Dims", "Size", "Description");
    println!("{}", "-".repeat(90));
    
    for model in models {
        let model_type = format!("{:?}", model.model_type);
        let size = format_size(model.size_bytes);
        let description = if model.description.len() > 20 {
            format!("{}...", &model.description[..17])
        } else {
            model.description.clone()
        };
        
        println!(
            "{:<35} {:<12} {:<8} {:<10} {:<20}",
            model.name,
            model_type,
            model.dimensions,
            size,
            description
        );
    }
    
    println!("\nUse 'tp models info <model-name>' for detailed information.");
    Ok(())
}

/// Show detailed information about a specific model
async fn show_model_info(model_name: &str) -> Result<()> {
    let model_info = ModelManager::get_model_info(model_name)
        .ok_or_else(|| anyhow::anyhow!("Model '{}' not found", model_name))?;
    
    println!("Model Information: {}", model_info.name);
    println!("================");
    println!("Type: {:?}", model_info.model_type);
    println!("Description: {}", model_info.description);
    println!("Embedding Dimensions: {}", model_info.dimensions);
    println!("Approximate Size: {}", format_size(model_info.size_bytes));
    println!("Source: {}", model_info.source);
    
    if let Some(context_length) = model_info.metadata.context_length {
        println!("Context Length: {} tokens", context_length);
    }
    
    if let Some(architecture) = &model_info.metadata.architecture {
        println!("Architecture: {}", architecture);
    }
    
    if let Some(quantization) = &model_info.metadata.quantization {
        println!("Quantization: {}", quantization);
    }
    
    // Check if model is cached
    let manager = ModelManager::default();
    let is_cached = manager.is_model_cached(&model_info.name);
    println!("Cached Locally: {}", if is_cached { "Yes" } else { "No" });
    
    // Show usage examples
    println!("\nUsage Examples:");
    println!("  tp --model {} index /path/to/code", model_info.name);
    println!("  tp --model {} search \"function definition\"", model_info.name);
    
    Ok(())
}

/// Download and cache a model
async fn download_model(model_name: &str) -> Result<()> {
    info!("Downloading model: {}", model_name);
    
    // Create a temporary embedding generator to trigger download
    let generator = EmbeddingGenerator::from_model_name(model_name).await?;
    
    println!("Model '{}' downloaded and cached successfully.", model_name);
    println!("Dimensions: {}", generator.embedding_dimensions());
    println!("Type: {:?}", generator.model_type());
    
    Ok(())
}

/// Remove a cached model
async fn remove_model(model_name: &str) -> Result<()> {
    let manager = ModelManager::default();
    manager.remove_model(model_name)?;
    println!("Model '{}' removed from cache.", model_name);
    Ok(())
}

/// Show cache statistics
async fn show_cache_stats() -> Result<()> {
    let manager = ModelManager::default();
    let stats = manager.get_cache_stats()?;
    
    println!("Model Cache Statistics:");
    println!("======================");
    println!("Models Cached: {}", stats.model_count);
    println!("Total Cache Size: {}", stats.format_size());
    
    // Show individual cached models
    if stats.model_count > 0 {
        println!("\nCached Models:");
        let available_models = ModelManager::get_available_models();
        for model in &available_models {
            if manager.is_model_cached(&model.name) {
                println!("  - {} ({} dims)", model.name, model.dimensions);
            }
        }
    }
    
    Ok(())
}

/// Format file size in human-readable format
fn format_size(bytes: u64) -> String {
    const UNITS: &[&str] = &["B", "KB", "MB", "GB"];
    let mut size = bytes as f64;
    let mut unit_index = 0;
    
    while size >= 1024.0 && unit_index < UNITS.len() - 1 {
        size /= 1024.0;
        unit_index += 1;
    }
    
    format!("{:.1}{}", size, UNITS[unit_index])
}
```

### 3. Update Configuration System
```rust
// In src/config.rs, update configuration to support new models

use crate::models::ModelManager;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Config {
    /// Default embedding model to use
    pub default_model: String,
    /// Cache directory for models
    pub cache_dir: PathBuf,
    /// Other config fields...
}

impl Default for Config {
    fn default() -> Self {
        Self {
            default_model: ModelManager::default_model().to_string(),
            cache_dir: dirs::cache_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join("turboprop")
                .join("models"),
        }
    }
}

impl Config {
    /// Validate configuration
    pub fn validate(&self) -> Result<()> {
        // Check if default model exists
        if !ModelManager::get_available_models()
            .iter()
            .any(|model| model.name == self.default_model)
        {
            return Err(anyhow::anyhow!(
                "Invalid default model: {}. Use 'tp models list' to see available models.",
                self.default_model
            ));
        }
        
        Ok(())
    }
    
    /// Get effective model name (from CLI arg or config default)
    pub fn get_effective_model(&self, cli_model: Option<&str>) -> String {
        cli_model.unwrap_or(&self.default_model).to_string()
    }
}
```

### 4. Update Main CLI Handler
```rust
// In src/main.rs, update command handling

use crate::commands::models::execute_models_command;

async fn run() -> Result<()> {
    let cli = Cli::parse();
    
    // Load configuration
    let config = Config::load_or_default()?;
    config.validate()?;
    
    // Get effective model name
    let model_name = config.get_effective_model(cli.model.as_deref());
    
    // Validate model name
    if !ModelManager::get_available_models()
        .iter()
        .any(|model| model.name == model_name)
    {
        eprintln!("Error: Unknown model '{}'. Available models:", model_name);
        eprintln!("Use 'tp models list' to see all available models.");
        return Err(anyhow::anyhow!("Invalid model specified"));
    }
    
    match cli.command {
        Commands::Index(cmd) => {
            let mut index_cmd = cmd;
            if index_cmd.model.is_none() {
                index_cmd.model = Some(model_name);
            }
            execute_index_command(index_cmd).await
        }
        Commands::Search(cmd) => {
            let mut search_cmd = cmd;
            if search_cmd.model.is_none() {
                search_cmd.model = Some(model_name);
            }
            execute_search_command(search_cmd).await
        }
        Commands::Models(cmd) => {
            execute_models_command(cmd.action).await
        }
    }
}
```

### 5. Update Help Text and Examples
```rust
// Update command help text to include new models

#[derive(Debug, Parser)]
pub struct IndexCommand {
    /// Path to index
    pub path: PathBuf,
    
    /// Embedding model to use
    #[arg(long, help = "Embedding model to use for indexing")]
    #[arg(long_help = "Embedding model to use for generating embeddings.
Examples:
  --model sentence-transformers/all-MiniLM-L6-v2  # Default, fast
  --model nomic-embed-code.Q5_K_S.gguf            # Best for code
  --model Qwen/Qwen3-Embedding-0.6B               # Highest accuracy")]
    pub model: Option<String>,
    
    // ... other fields
}

#[derive(Debug, Parser)]
pub struct SearchCommand {
    /// Search query
    pub query: String,
    
    /// Embedding model to use
    #[arg(long, help = "Embedding model to use for search")]
    #[arg(long_help = "Must match the model used during indexing.
Use 'tp models list' to see available models.")]
    pub model: Option<String>,
    
    // ... other fields
}
```

### 6. Add Environment Variable Support
```rust
// In src/config.rs, add environment variable support

impl Config {
    /// Load configuration from file and environment variables
    pub fn load_or_default() -> Result<Self> {
        let mut config = Self::default();
        
        // Override with environment variables
        if let Ok(model) = std::env::var("TURBOPROP_MODEL") {
            config.default_model = model;
        }
        
        if let Ok(cache_dir) = std::env::var("TURBOPROP_CACHE_DIR") {
            config.cache_dir = PathBuf::from(cache_dir);
        }
        
        // Load from config file if it exists
        let config_path = dirs::config_dir()
            .map(|dir| dir.join("turboprop").join("config.toml"));
            
        if let Some(path) = config_path {
            if path.exists() {
                let config_str = std::fs::read_to_string(&path)?;
                let file_config: Config = toml::from_str(&config_str)?;
                config = file_config;
            }
        }
        
        Ok(config)
    }
}
```

## Test Coverage
Add tests for:
- CLI argument parsing with new models
- Model validation in configuration
- Model management commands
- Help text generation
- Environment variable handling
- Configuration file loading

## Acceptance Criteria
- [ ] CLI supports all new model names
- [ ] `tp models list` shows all available models
- [ ] `tp models info <model>` shows detailed model information
- [ ] Model validation works in CLI argument parsing
- [ ] Help text includes examples with new models
- [ ] Environment variables override configuration
- [ ] Configuration file support works
- [ ] Error messages guide users to available models
- [ ] Backward compatibility maintained
- [ ] Comprehensive test coverage

## Files to Create/Modify
- `src/cli.rs` - Add model arguments and help text
- `src/commands/models.rs` - New file for model management
- `src/commands/mod.rs` - Add models module
- `src/config.rs` - Update configuration system
- `src/main.rs` - Update command handling
- `Cargo.toml` - Add toml dependency if needed

## Success Validation
```bash
# Build should succeed
cargo build --release

# Test model commands
./target/release/tp models list
./target/release/tp models info "sentence-transformers/all-MiniLM-L6-v2"
./target/release/tp models info "nomic-embed-code.Q5_K_S.gguf"
./target/release/tp models info "Qwen/Qwen3-Embedding-0.6B"

# Test help text
./target/release/tp --help
./target/release/tp index --help
./target/release/tp search --help

# Test model validation
./target/release/tp --model "invalid-model" search "test" 2>&1 | grep -i "unknown model"
```

## Notes
This step makes the new models accessible to end users through a clean CLI interface. The model management commands help users understand and manage the different embedding models available.

The help text is comprehensive to guide users in selecting appropriate models for their use cases. The nomic-embed-code model is highlighted for code search, while Qwen3 is positioned for high-accuracy general use.